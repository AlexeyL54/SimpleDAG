# Simple DAG

Упрощенный аналог Apache Airflow для построения и выполнения направленных ациклических графов (DAG) операций над табличными данными.

## Описание проекта

Терминальная программа для создания и выполнения последовательностей операций над CSV-файлами с использованием направленного ациклического графа. Проект позволяет:

- Загружать данные из CSV файлов
- Определять последовательности операций из YAML конфигурации
- Строить граф операций с проверкой на ацикличность
- Выполнять различные операции над табличными данными
- Сохранять результаты обработки

## Структура проекта

### Основные модули

**`graph.h`**
- Основные операции для работы с графами
- Реализация графа с помощью списка смежности
- Управление структурой графа операций
- Проверка графа на ацикличность
- Обход графа и управление узлами

**`parser.h`**
- Парсинг конфигурационных файлов
- Извлечение параметров для операций
- Чтение данных из таблиц (столбцы, ячейки, области)

**`operations.h`**
- Содержит словарь операций над таблицами
- Соответствие ID операций названиям и указателям на функции
- Реализация операций над данными
- Математические операции (сумма, среднее)
- Строковые операции (конкатенация, поиск и замена)
- Валидация данных

**`router.h`**
- Основной координатор приложения
- Управление конфигурациями
- Запуск выполнения операций
- Сохранение результатов

**`utils.h`**
- Вспомогательные функции
- Работа с файловой системой
- проход по графу
- Валидация конфигураций

## Прототипы и API

### graph.h

```C
/**
 * @brief Структура вершины графа
*/ 
struct Element{  
  string id;      // Уникальный идентификатор узла
  Node *ptr;      // Указатель на следующий узел
};

typedef Element Node;

/**
 * @brief Структура элемента списка заголовков
 */
struct Head{
  Node *node_ptr;        // Указатель на вершину
  Head *next_head_ptr;   // Указатель на следующую вершину в списке
}

// Глобальные указатели для управления графом
Node *first_node;        // Указатель на первый узел графа
Head *first_head_ptr;    // Указатель на первый заголовок графа

/**
 * @brief Создает новый узел графа с заданным идентификатором
 * @param id Уникальный идентификатор узла
 * @return Указатель на созданный узел
 */
Node *createNode(string id);

/**
 * @brief Возвращает указатель на первый (корневой) узел графа
 * @return Указатель на корневой узел
 */
Node *firstNode();

/**
 * @brief Получает вектор всех узлов, следующих за указанным узлом
 * @param node Указатель на исходный узел
 * @return Вектор указателей на следующие узлы
 */
vector<Node *> nextNodes(Node *);

/**
 * @brief Добавляет новый узел в граф, связывая его с существующим узлом
 * @param atom Указатель на добавляемый узел
 * @param to Указатель на узел назначения (по умолчанию - корневой узел)
 */
void addNode(Node *atom, Node *to = first_node);

/**
 * @brief Удаляет узел из графа и все связанные с ним связи
 * @param element Указатель на удаляемый узел
 */
void deleteNode(Node *element);

/**
 * @brief Проверяет граф на наличие циклов
 * @return true если граф ациклический, false если обнаружены циклы
 */
bool isGraphAcyclic();

/**
 * @brief Полностью очищает граф, удаляя все узлы
 */
void clearGraph();

/**
 * @brief Проверяет, содержит ли граф какие-либо узлы
 * @return true если граф пуст, false если содержит узлы
 */
bool isGraphEmpty();
```

### operations.h

```C 
/**
 * @brief Словарь операций, поддерживающий различные типы данных через variant
 * Ключ: идентификатор операции
 * Значение: функция соответствующего типа
 */
map<string, variant<
  function<double(vector<double>)>,          // Функции для числовых данных
  function<string(vector<string>)>,          // Функции для строковых данных
  function<double(vector<Cell>)>             // Функции для работы с ячейками
  function<string(vector<Cell>)>             // Функции для работы с ячейками
>> operation_map;

/**
 * @brief Вычисляет сумму элементов числового вектора
 * @param source Входной вектор числовых данных
 * @return Сумма всех элементов
 */
double sum(vector<double> source);

/**
 * @brief Вычисляет среднее арифметическое элементов числового вектора
 * @param source Входной вектор числовых данных
 * @return Среднее значение элементов
 */
double average(vector<double> source);

/**
 * @brief Объединяет строки из вектора в одну строку
 * @param source Входной вектор строк
 * @return Результирующая объединенная строка
 */
string concatinate(vector<string> source);

/**
 * @brief Выполняет поиск и замену в векторе строк
 * @param source Входной вектор строк
 * @param find Строка для поиска
 * @param replace Строка для замены
 * @return Вектор с выполненными заменами
 */
vector<string> findReplace(vector<string> source, 
                           string find, string replace);
```

### parser.h 

```C 
/**
 * @brief Структура, представляющая позицию ячейки в таблице
 */
struct Cell{
  int column;  // Номер столбца (начиная с 0)
  int row,     // Номер строки (начиная с 0)
};

/**
 * @brief Перечисление типов данных столбцов таблицы
 */
enum ColumnType {
  NUMERIC,    // Столбец содержит только числовые данные
  STRING,     // Столбец содержит только строковые данные  
  MIX         // Столбец содержит данные разных типов
  UNKNOWN,    // Тип данных не определен
};

/**
 * @brief Определяет тип данных столбца
 * @param head Заголовок столбца
 * @return Тип данных столбца
 */
ColumnType getTypeOfColumn(string head);

/**
 * @brief Определяет тип данных столбца
 * @param cells Вектор ячеек столбца
 * @return Тип данных столбца
 */
ColumnType getTypeOfColumn(vector<Cell> cells);

/**
 * @brief Читает строковый столбец таблицы по заголовку
 * @param head Заголовок столбца
 * @return Вектор строковых значений столбца
 */
vector<string> readStringColumn(string head);

/**
 * @brief Читает строковый столбец таблицы по набору ячеек
 * @param cells Вектор ячеек для чтения
 * @return Вектор строковых значений
 */
vector<string> readStringColumn(vector<Cell> cells);

/**
 * @brief Читает числовой столбец таблицы по заголовку
 * @param head Заголовок столбца
 * @return Вектор числовых значений столбца
 */
vector<double> readNumericColumn(string head);

/**
 * @brief Читает числовой столбец таблицы по набору ячеек
 * @param cells Вектор ячеек для чтения
 * @return Вектор числовых значений
 */
vector<double> readNumericColumn(vector<Cell> cells);
```

### utils.h
```C 
/**
 * @brief Собирает список файлов в указанной директории
 * @param path Путь к директории
 * @return Вектор имен файлов
 */
vector<string> collectFilesIn(string path);

/**
 * @brief Выполняет операцию над данными
 */
void executeOperation();

/**
 * @brief Проверяет корректность конфигурационного файла
 * @param path Путь к конфигурационному файлу
 * @return true если конфиг корректен, false если есть ошибки
 */
bool checkConfig(string path);
```

### router.h 
```C
/**
 * @brief Основная функция запуска приложения
 */
void runApp();

/**
 * @brief Предоставляет пользователю выбор конфигурационного файла
 * @return Имя файла конфигурации
 */
string chooseConfig();

/**
 * @brief Предоставляет пользователю выбор файла csv
 * @return Имя файла csv
 */
string chooseSourceFile();

/**
 * @brief Запрашивает у пользователя сценарий операций
 */
void manageTasks();

/**
 * @brief Запрашивает у пользователя имя файла для сохранения результатов
 * @return Имя файла для сохранения
 */
string getFileName();

/**
 * @brief Запускает выполнение операций согласно построенному графу
 */
void runOperations();

/**
 * @brief Сохраняет результаты выполнения операций в файл
 */
void saveResults();
```
## Алгоритм работы

### 📋 Псевдокод

```plaintext
вывести список csv файлов
если список пуст:
  уведомить пользователя
  вернуться назад
запросить у пользователя выбор csv файла

вывести список конфигурационных файлов
если список пуст:
  уведомить пользователя
  вернуться назад

выбрать конфиг
считать конфиг
проверить конфиг

если конфиг имеет ошибки:
  уведомить пользователя
  вернуться к выбору конфига

вывести доступные операции в конфиге
пока не закончено формирование сценария операций:
  запросить выбор операции
  добавить операцию в граф

проверить граф на ацикличность
если граф имеет циклы:
  уведомить пользователя 
  убрать циклы или вернуться к формированию сценария?

запросить название файла для сохранения результатов
запустить выполнение задач

пока не прошлись по всем узлам графа:
  извлечь id операции из узла
  по полученному id найти указатель на функцию операции в словаре
  получить параметры для этой функции из конфига
  получить тип начальных данных 
  считать начальные данные для обработки из таблицы csv

  если начальные данные разного типа и это не предусмотрено операцией:
    пропустить операцию
    внести соответствующую информацию в журнал или вывести сразу в консоль?

  вызвать функцию

сохранить результат в файл
уведомить о выполнении задач
```

## Зависимости

- **YAML парсер**: [mini-yaml](https://github.com/jimmiebergmann/mini-yaml)
- **CSV парсеры**: 
  - [ssp](https://github.com/red0124/ssp)
  - [csv-parser](https://github.com/vincentlaucsb/csv-parser)
  - [lazycsv](https://github.com/ashtum/lazycsv)

## Пример конфигурации

```yaml
operations:
  - discription: "сумма цен"
    id: "sum"
    column: "sales"
    cells: ~ 
  - discription: "средняя цена" 
    id: "average"
    column: None
    cells: ~
  - discription: "соединить имена"
    id: "concatinate"
    column: "customer_name"
    cells: 
      - column: 0
        row: 0 
      - column: 1 
        row: 1

```

## Разработка

Проект находится в активной разработке. Основные направления:

- Расширение набора операций
- Улучшение обработки ошибок
- Оптимизация производительности
- Добавление поддержки новых форматов данных
