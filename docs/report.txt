#import "@preview/lovelace:0.3.0" : *
#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *
#import "@preview/fletcher:0.5.8" as fletcher: diagram, node, edge
#import "@preview/big-todo:0.2.0": todo, todo_outline
#show: codly-init.with()

#set page(
  width: 210mm,
  height: 297mm,
  margin: 2.5cm,
  numbering: "1",
)

#set text(font: "BlexMono Nerd Font Mono")
#counter(page).update(1)
#set text(size: 14pt, lang: "ru")
#set heading(numbering: "1.")

#let param(string) = {
  highlight(
    fill: gray.lighten(70%),  // Серый цвет (можно настроить оттенок)
    radius: 4pt,              // Закругление углов
    [#string]                 // Выделяемый текст
  )
}

#let pict(path, cap: "") = {
  figure(
    image(path),
    caption: [#cap]
  )
}

#let listing(path) = {
  let listing = read(path)
  set text(size: 10pt)
  raw(listing, block: true, lang: "cpp")

}

#align(center)[

  #set text(size: 16pt)
  *
  МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ
  РОССИЙСКОЙ ФЕДЕРАЦИИ
  * \

  #v(1cm)
  *
  ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ \
  «МОСКОВСКИЙ АВИАЦИОННЫЙ ИНСТИТУТ
  (НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ)»
  *

  #v(1cm)
  #set text(size: 16pt)
  Институт № 7 \
  «Робототехнические и интеллектуальные системы» \

  Кафедра 703 \
  «Системное проектирование авиакомплексов»

  #v(1cm)
  ОТЧЕТ №2 \
  о лабораторной работе по курсу\
  «Алгоритмы и структуры данных»
]

#v(2cm)

#align(right)[
  #box(width: 8cm, inset: 0pt, stroke: none)[
    Разработал: \
    Студент группы М70-306С-22 \
    Лапшин А. А. \ #underline("                           ")

    Принял:\
    Старший преподаватель кафедры 703 \
    Барчев Н. Б. \ #underline("                           ")
  ]
]

#align(bottom)[
  #align(center)[Москва, 2025]
]

#pagebreak()

// ------------------------------------------------------------------------------------
#set outline(
  title: [Содержание], // можно изменить название
  indent: 1em, // отступ для подразделов
)
#outline()
#pagebreak()
// ------------------------------------------------------------------------------------

#align(center)[
  #set text(size: 18pt)
  = Задание 
]

Динамическая структура приведенного ниже вида содержит элементы различного типа. Необходимо выполнить программную реализацию построения данной структуры и работы с ней на основе связанного динамического распределения памяти, *используя ручное управление памятью*.

*Требования к проектированию*:

- обеспечить возможность ввода элементов структуры данных как из текстового файла, так и с клавиатуры;
- обеспечить возможность сохранения построенной структуры в текстовый файл;
- реализовать базовые операции работы со структурой: добавление элементов структуры *в конец* соответствующих последовательностей элементов (ствола и ветвей); удаление произвольных элементов из структуры с сохранением ее целостности;
- *Реализовать дополнительные операции по согласованию с преподавателем* (сортировку предметов в прямом и обратном алфавитном порядке; вывод по запросу пользователя списка предметов, имеющих конкретную, указанную пользователем форму контроля);
- в обязательном порядке использовать языковые средства организации программных единиц;
- *в соответствии с общими стилистическими рекомендациями обеспечить минимизацию объема программных единиц и использования дублированного кода*;
- использовать средства одной из реализаций языка программирования C++.

Исходные элементы данных вводятся и хранятся в текстовом файле в следующем виде:

```txt
ОПРТС ЗАЧЕТ ЭКЗАМЕН
ТВиМС ЭКЗАМЕН КР
```

#pagebreak()
// --------------------------------------------------------------------------------------

#align(center)[
  #set text(size: 18pt)
  = Псевдокод
]

#pseudocode-list(booktabs: true)[

+ Проверить существование папки "txt"
+ *ЕСЛИ* папка не существует:
    + создать папку "txt"

+ #v(1em)
+ *ПОКА* не нажат TAB:
+ #v(1em)
  + *ЕСЛИ* связный список предметов и форм контроля пуст:
    + вывести меню с пунктами:
      - 1. Загрузить расписание из файла
      - 2. Редактировать текущее расписание
    + ожидать ввод пользователя
    + #v(1em)
    + #line-label(<download>) *ЕСЛИ* пользователь ввел 1:
      + получить список файлов из папки "txt"
      + *ЕСЛИ* список пуст:
        + уведомить пользователя
      + *ИНАЧЕ*:
        + вывести список файлов для выбора
        + получить индекс файла в массиве от пользователя
        + *ЕСЛИ* файл выбран:
          + открыть файл для чтения
          + *ДЛЯ* каждой строки в файле:
            + считать название предмета (первое слово)
            + создать новый объект предмета с этим названием
            + добавить в связный список предметов
            + *ДЛЯ* остальных слов в строке:
              + создать объект формы контроля
              + добавить его к созданному предмету
          + закрыть файл
          + вывести меню операций над данными (см. ниже)
        + *ИНАЧЕ* (отмена):
          + вернуться назад
  + #v(1em)
    + #line-label(<edit>) *ЕСЛИ* пользователь ввел 2:
      + *ЕСЛИ* (связный список предметов и форм контроля не пуст):
        + вывести меню с операциями:
          + 1. Добавить предмет
          + 2. Удалить предмет
          + 3. Добавить рубежный контроль
          + 4. Удалить рубежный контроль
          + 5. Просмотреть структуру
          + 6. Поиск по предметам
          + 7. Сохранить
      + *ИНАЧЕ* (список пуст):
        + вывести меню с операциями:
          + 1. Добавить предмет
          + 2. Удалить предмет
          + 3. Добавить рубежный контроль
          + 4. Удалить рубежный контроль
          + 5. Просмотреть структуру
          + 6. Поиск по предметам
    + #v(1em)
        + ожидать ввод пользователя
        + *ЕСЛИ* пользователь ввел 1 (Добавить предмет):
          + запросить название предмета у пользователя
          + *ЕСЛИ* название введено корректно и не отменено:
            + создать новый объект предмета
            + добавить в связный список предметов
            + уведомить пользователя об успешном добавлении предмета
            + ждать нажатия клавиши
    + #v(1em)
        + *ИНАЧЕ ЕСЛИ* пользователь ввел 2 (Удалить предмет):
          + *ЕСЛИ* список предметов пуст:
            + уведомить пользователя об отсутствии предметов
            + ждать нажатия любой клавиши
          + *ИНАЧЕ*:
            + вывести список предметов для выбора
            + ожидать ввод пользователя
            + *ЕСЛИ* выбран предмет:
              + удалить предмет из связного списка по индексу, который ввел пользователь
              + вывести сообщение об успешном удалении
              + ждать нажатия клавиши
    + #v(1em)
        + *ИНАЧЕ ЕСЛИ* пользователь ввел 3 (Добавить форму контроля):
          + *ЕСЛИ* связный список предметов и форм контроля пуст:
            + уведомить пользователя об отсутствии предметов
            + ждать нажатия любой клавиши
          + *ИНАЧЕ*:
            + вывести список предметов для выбора
            + ожидать выбор предмета пользователем
            + *ЕСЛИ* выбран предмет:
              + показать меню с вариантами формы контроля
              + ожидать ввод пользователя
              + создать новый объект выбранной формы контроля по индексу, который ввел пользователь
              + добавить к выбранному предмету
              + вывести сообщение об успешном добавлении или об ошибке удаления
              + ждать нажатия любой клавиши
    + #v(1em)
        + *ИНАЧЕ ЕСЛИ* пользователь ввел 4 (Удалить форму контроля):
          + *ЕСЛИ* связный список предметов и форм контроля пуст:
            + уведомить пользователя об отсутствии предметов
            + ждать нажатия любой клавиши
          + *ИНАЧЕ*:
            + ожидать выбор предмета пользователем
            + *ЕСЛИ* выбран предмет:
              + получить список форм контроля выбранного предмета
              + *ЕСЛИ* список пуст:
                + уведомить пользователя об отсутствии форм контроля
                + ждать нажатия любой клавиши
              + *ИНАЧЕ*:
                + вывести список форм контроля
                + ожидать ввод пользователя
                + *ЕСЛИ* форма контроля выбрана:
                  + удалить рубежный контроль по индексу, который ввел пользователь
                  + вывести сообщение об успешном удалении
                  + ждать нажатия любой клавиши
    + #v(1em)
        + *ИНАЧЕ ЕСЛИ* пользователь ввел 5 (Просмотреть расписание):
          + *ЕСЛИ* связный список предметов и форм контроля пуст:
            + уведомить пользователя об отсутствии предметов
            + ждать нажатия любой клавиши
        + *ИНАЧЕ*:
            + итерировать по предметам
              + вывести название предмета
              + вывести связанные формы контроля через пробел
              + ожидать нажатия
              + *ЕСЛИ* пользователь ввел "a":
                + отсортировать пункты меню по возрастанию
                + перерисовать пункты меню
              + *ЕСЛИ* пользователь ввел "d":
                + отсортировать пункты меню по убыванию
                + перерисовать пункты меню
          
    + #v(1em)
        + *ИНАЧЕ ЕСЛИ* пользователь ввел 6 (Поиск по предметам):
          + *ПОКА* не нажат TAB или ENTER:
            + запросить ввод поисковой подстроки
            + итерировать по предметам:
              + *ЕСЛИ* форма контроля содержит подстроку:
                + вывести предмет с найденной формой контроля и его остальные формы контроля

            + *ЕСЛИ* ничего не найдено:

              + вывести "Ничего не найдено"
    + #v(1em)
        + *ИНАЧЕ ЕСЛИ* пользователь ввел 7 (Сохранить):
          + *ЕСЛИ* если расписание загружено из одного файла, и путь к этому файлу известен:
            + показать меню "Сохранить как?" с вариантами:
              + 1. Сохранить в "название исходного файла"
              + 2. Сохранить в новый файл
            + ожидать ввод пользователя
            + *ЕСЛИ* пользователь ввел 1:
              + открыть исходный файл для записи
              + сохранить связанный список
              + закрыть файл
            + *ИНАЧЕ ЕСЛИ* пользователь ввел 2:
              + запросить название нового файла
              + сохранить структуру в новый файл
          + *ИНАЧЕ*:
            + запросить имя нового файла
            + сохранить связанный список в новый файл
          + вывести сообщение об успехе или ошибке создания файла
          + ждать нажатия любой клавиши

  + #v(1em)
  + *ИНАЧЕ* (связный список предметов и форм контроля не пуст):
    + вывести меню с пунктами:
      - 1. Сохранить
      - 2. Загрузить расписание из файла
      - 3. Редактировать текущее расписание
      - 4. Очистить текущее расписание
    + ожидать ввод пользователя

      + *ЕСЛИ* #line-label(<save>) пользователь ввел 1:
        + *ЕСЛИ* расписание загружено из одного файла, и путь к этому файлу известен:
          + показать меню "Сохранить как?" с вариантами:
            + 1. Сохранить в "название исходного файла"
            + 2. Сохранить в новый файл
          + ожидать ввод пользователя
          + *ЕСЛИ* пользователь ввел 1:
            + открыть исходный файл для записи
            + сохранить связанный список
            + закрыть файл
          + *ИНАЧЕ ЕСЛИ* пользователь ввел 2:
            + запросить название нового файла
            + сохранить структуру в новый файл
        + *ИНАЧЕ*:
          + запросить имя нового файла
          + сохранить связанный список в новый файл
        + вывести сообщение об успехе или ошибке
        + ждать нажатия любой клавиши

      + *ИНАЧЕ ЕСЛИ* пользователь ввел 2:
        + получить список файлов из папки "txt"
        + *ЕСЛИ* список пуст:
          + уведомить пользователя
          + вернуться назад
        + *ИНАЧЕ*:
          + вывести список файлов для выбора
          + получить индекс файла в массиве от пользователя
          + *ЕСЛИ* файл выбран:
            + открыть файл для чтения
            + *ДЛЯ* каждой строки в файле:
              + считать название предмета (первое слово)
              + создать новый объект предмета с этим названием
              + добавить в связный список предметов
              + *ДЛЯ* остальных слов в строке:
                + создать объект формы контроля
                + добавить его к созданному предмету
            + закрыть файл
            + вывести меню операций над данными (см. ниже)
          + *ИНАЧЕ* (отмена):
            + вернуться назад


      + *ИНАЧЕ ЕСЛИ* пользователь ввел 3:
        + *ЕСЛИ* (связный список предметов и форм контроля не пуст):
          + вывести меню с операциями:
            + 1. Добавить предмет
            + 2. Удалить предмет
            + 3. Добавить рубежный контроль
            + 4. Удалить рубежный контроль
            + 5. Просмотреть структуру
            + 6. Поиск по предметам
            + 7. Сохранить
        + *ИНАЧЕ* (список пуст):
          + вывести меню с операциями:
            + 1. Добавить предмет
            + 2. Удалить предмет
            + 3. Добавить рубежный контроль
            + 4. Удалить рубежный контроль
            + 5. Просмотреть структуру
            + 6. Поиск по предметам


      + *ИНАЧЕ ЕСЛИ* пользователь ввел 4:
        + показать меню с подтверждением
        + *ЕСЛИ* пользователь подтвердил:
          + удалить связанный список
          + вывести сообщение об очистке
          + ждать нажатия любой клавиши

+ #v(1em)
  + *ЕСЛИ* есть несохраненные изменения в расписании и связный список предметов и форм контроля не пуст:
    + вывести меню "Сохранить изменения?" с пунктами:
      - 1. Да
      - 2. Нет
    + ожидать ввод пользователя
    + *ЕСЛИ* пользователь ввел 1:
      + *ЕСЛИ* расписание загружено из одного файла, и путь к этому файлу известен:
        + показать меню "Сохранить как?" с вариантами:
          + 1. Сохранить в "название исходного файла"
          + 2. Сохранить в новый файл
        + ожидать ввод пользователя
        + *ЕСЛИ* пользователь ввел 1:
          + открыть исходный файл для записи
          + сохранить связанный список
          + закрыть файл
        + *ИНАЧЕ ЕСЛИ* пользователь ввел 2:
          + запросить название нового файла
          + сохранить структуру в новый файл
      + *ИНАЧЕ*:
        + запросить имя нового файла
        + сохранить связанный список в новый файл
      + вывести сообщение об успехе или ошибке
      + ждать нажатия любой клавиши
      + завершить программу
    + *Если* пользователь ввел 2:
      + завершить программу
]

#pagebreak()
// --------------------------------------------------------------------------------------

#align(center)[
  #set text(size: 18pt)
  = Сведения о программной реализации
]

== Язык программирования и среда разработки

Программа написана на языке программирования C++ (стандарт ISO/IEC
14882:2017) в среде разработки с открытым исходным кодом LazyVim
(готовая конфигурация NeoVim).

== Описание входных и выходных данных

*Входные данные*:
- нажатия клавиш;
- текстовые файлы специального формата.

*Выходные данные*:
- текстовые файлы специального формата.

Пример текстового файла:

```txt
ТВиМС ЗАЧЁТ КП КР
МАТАН ЭКЗАМЕН
ТАУ КП ЭКЗАМЕН ЗАЧЁТ
```

== Программный интерфейс

=== Файл routes.cpp

*Глобальные переменные*:
- #param("int changes = 0") — флаг наличия несохранённых изменений (1 — есть изменения, 0 — нет)
- #param("int saved = 1") — флаг статуса сохранения (1 — сохранено, 0 — не сохранено)
- #param("int source_files_total = 0") — количество загруженных файлов

```cpp
void freePath(char **path);
```
*Описание* \
Очищает выделенную память под путь к файлу.

*Параметры*
- #param("path") - путь к файлу

#line(stroke: 1pt, length: 100%)

```cpp
void searcher(struct entry *properties);
```
*Описание* \
Осуществляет поиск предметов по введённому пользователем запросу и выводит результаты на экран.

*Параметры*:
- #param("properties") — указатель на структуру #param("entry"), содержащую буфер для поиска и координаты вывода.

#line(stroke: 1pt, length: 100%)

```cpp
void search();
```
*Описание* \
Запрашивает у пользователя название предмета для поиска и вызывает функцию #param("searcher") для обработки запроса.

#line(stroke: 1pt, length: 100%)

```cpp
void clearProject();
```
*Описание* \
Очищает текущую структуру проекта, включая все предметы и рубежные контроля.

#line(stroke: 1pt, length: 100%)

```cpp
void saveToNewFile();
```
*Описание* \
Сохраняет текущую структуру проекта в новый файл с именем, указанным пользователем.

#line(stroke: 1pt, length: 100%)

```cpp
void saveAs(const char *path);
```
*Описание* \
Предоставляет пользователю выбор: сохранить изменения в текущий файл или создать новый.

*Параметры*:
- #param("path") — путь к текущему файлу проекта.

#line(stroke: 1pt, length: 100%)

```cpp
void saveChanges(const char *path);
```
*Описание* \
Сохраняет изменения в текущий файл или создаёт новый, если файл не указан.

*Параметры*:
- #param("path") — путь к текущему файлу проекта.

#line(stroke: 1pt, length: 100%)

```cpp
void doYouWantToSave(const char *path);
```
*Описание* \
Запрашивает у пользователя подтверждение на сохранение изменений перед выходом.

*Параметры*:
- `path` — путь к текущему файлу проекта.

#line(stroke: 1pt, length: 100%)

```cpp
int chooseSubject();
```
*Описание* \
Отображает список предметов и возвращает индекс выбранного пользователем предмета.

*Возвращаемое значение*: 
Индекс выбранного предмета (начиная с 1) или `-1`, если выбор отменён.

#line(stroke: 1pt, length: 100%)

```cpp
void appendSubject();
```
*Описание* \
Добавляет новый предмет в структуру проекта.

#line(stroke: 1pt, length: 100%)

```cpp
void deleteSubject();
```
*Описание* \
Удаляет выбранный предмет из структуры проекта.

#line(stroke: 1pt, length: 100%)

```cpp
void appendAppraival();
```
*Описание* \
Добавляет рубежный контроль к выбранному предмету.

#line(stroke: 1pt, length: 100%)

```cpp
void deleteAppraival();
```
*Описание* \
Удаляет рубежный контроль у выбранного предмета.

#line(stroke: 1pt, length: 100%)

```cpp
void viewStructure();
```
*Описание* \
Отображает полную структуру проекта в виде списка.

*Формат*:
`Предмет ФормаКонтроля1 ФормаКонтроля2 ...`

#line(stroke: 1pt, length: 100%)

```cpp
char* chooseFile();
```
*Описание* \
Позволяет пользователю выбрать файл из директории `txt/` для загрузки.

*Возвращает*:
Путь к выбранному файлу или `NULL` при отмене.

#line(stroke: 1pt, length: 100%)

```cpp
char* chooseOperation(char* path = NULL);
```
*Описание* \
Основной цикл операций с проектом.

*Параметры*:
- `path` — путь к текущему файлу проекта

#line(stroke: 1pt, length: 100%)

```cpp
void runApp();
```
*Описание* \
Главный цикл приложения, управляющий основным потоком выполнения.

// ----------------------------------------------------------------------------------

=== Файл lists.cpp

*Глобальные переменные*:
- #param("Subject* sub_head_ptr = NULL") — указатель на первый элемент списка предметов
- #param("Subject* sub_tail_ptr = NULL") — указатель на последний элемент списка предметов  
- #param("int subjects_total = 0") — количество предметов в списке

#line(stroke: 1pt, length: 100%)

*Структуры*:
```cpp
struct Subject {
  char name[64];              // название предмета
  Appraival* appraival_head;  // указатель на первую форму контроля
  Subject* next_subject;      // указатель на следующий предмет
};

struct Appraival {
  char name[64];              // название формы контроля
  Appraival* next_appraival;  // указатель на следующую форму контроля
};
```

```cpp
void initSubjects(Subject* first);
```
*Описание* \
Инициализирует список предметов первым элементом.

*Параметры*:
- #param("first") — указатель на первый предмет

#line(stroke: 1pt, length: 100%)

```cpp
void clearList();
```
*Описание* \
Полностью очищает связный список предметов и форм контроля, освобождая всю память.

#line(stroke: 1pt, length: 100%)

```cpp
Subject* getSubjectByIndex(int index);
```
*Описание* \
Возвращает предмет по указанному индексу.

*Параметры*:
- #param("index") — индекс предмета (0-based)

*Возвращает*:
Указатель на Subject или NULL при ошибке

#line(stroke: 1pt, length: 100%)

```cpp
Appraival* getAppraivalByIndex(Appraival* head, int index);
```
*Описание* \
Возвращает форму контроля по индексу в рамках предмета.

*Параметры*:
- #param("head") — указатель на первую форму контроля
- #param("index") — индекс формы контроля (0-based)

#line(stroke: 1pt, length: 100%)

```cpp
void addSubject(Subject* new_element);
```
*Описание* \
Добавляет предмет в конец списка.

*Параметры*:
- #param("new_element") — указатель на новый предмет

#line(stroke: 1pt, length: 100%)

```cpp
void addAppraival(Subject* subject, Appraival* new_element);
```
*Описание* \
Добавляет форму контроля к указанному предмету.

*Параметры*:
- #param("subject") — указатель на предмет
- #param("new_element") — указатель на новую форму контроля

#line(stroke: 1pt, length: 100%)

```cpp
void removeSubject(int index);
```
*Описание* \
Удаляет предмет по индексу и все связанные формы контроля.

*Параметры*:
- #param("index") — индекс удаляемого предмета

#line(stroke: 1pt, length: 100%)

```cpp
void removeAppraival(Subject* subject, int index);
```
*Описание* \
Удаляет форму контроля у указанного предмета.

*Параметры*:
- #param("subject") — указатель на предмет
- #param("index") — индекс удаляемой формы контроля

#line(stroke: 1pt, length: 100%)

```cpp
Subject* createSubject(const char* subject_name);
```
*Описание* \
Создает новый экземпляр предмета.

*Параметры*:
- #param("subject_name") — название предмета

*Возвращает*:
Указатель на созданный Subject или NULL при ошибке

#line(stroke: 1pt, length: 100%)

```cpp
Appraival* createAppraival(const char* appraival_name);
```
*Описание* \
Создает новый экземпляр формы контроля.

*Параметры*:
- `appraival_name` — название формы контроля

*Возвращает*:
Указатель на созданный Appraival или NULL при ошибке

#line(stroke: 1pt, length: 100%)

```cpp
void readTXT(const char* file_name);
```
*Описание* \
Читает структуру данных из текстового файла.

*Формат файла*:
Каждая строка: `предмет форма_контроля1 форма_контроля2 ...`

#line(stroke: 1pt, length: 100%)

```cpp
void saveList(const char* path);
```
*Описание* \
Сохраняет текущую структуру в файл.

*Формат записи*:
Совпадает с форматом чтения `readTXT`

#line(stroke: 1pt, length: 100%)

```cpp
const char** getNamesOfSubjects();
```
*Описание* \
Возвращает массив названий всех предметов.

*Возвращает*:
Массив строк или NULL при ошибке

*Память*:
Требует освобождения через `free2DBuffer()`

#line(stroke: 1pt, length: 100%)

```cpp
const char** getNamesOfAppraivals(Subject* subject, int* amount_of_appraivals);
```
*Описание* \
Возвращает массив названий форм контроля для указанного предмета.

*Параметры*:
- #param("subject") — указатель на предмет
- #param("amount_of_appraivals") — указатель для возврата количества форм

#line(stroke: 1pt, length: 100%)

```cpp
const char** getStructure();
```
*Описание* \
Возвращает полную структуру данных в виде массива строк.

*Формат строк*:
предмет форма_контроля1 форма_контроля2 ...

*Особенности*:
- Последний элемент массива всегда NULL
- Требует освобождения через `cleanupPartialStructure()`

#line(stroke: 1pt, length: 100%)

```cpp
int countAppraivals(Subject* subject);
```
*Описание* \
Подсчитывает количество форм контроля у предмета.

*Параметры*:
- #param("subject") — указатель на предмет

*Возвращает*:
Количество форм контроля

#line(stroke: 1pt, length: 100%)
//---------------------------------------------------------------------------------------

=== Файл stdmanip.cpp


```cpp
void free2DBuffer(void **ptr, const int n);
```
*Описание* \
Безопасно освобождает двумерный массив.

*Параметры*:
- #param("ptr") — указатель на массив указателей.
- #param("n") — количество элементов в массиве.

*Особенности*:
Рекурсивно освобождает память для каждого элемента перед освобождением самого массива.

#line(stroke: 1pt, length: 100%)

```cpp
size_t unicodeStrlen(const char *str);
```
*Описание* \
Вычисляет длину строки с поддержкой Unicode (UTF-8).

*Параметры*:
- #param("str") — строка для измерения.

*Возвращаемое значение*:
Количество символов (не байт) с учётом многобайтовых UTF-8 последовательностей.

#line(stroke: 1pt, length: 100%)

```cpp
char *concat(const char *str1, const char *str2);
```
*Описание* \
Конкатенирует две строки с выделением новой памяти.

*Параметры*:
- #param("str1") — первая строка.
- #param("str2") — вторая строка.

*Возвращаемое значение*:
Указатель на новую строку или `NULL` при ошибке выделения памяти.

#line(stroke: 1pt, length: 100%)

```cpp
int isSubstring(const char *str1, const char *str2);
```
*Описание* \
Проверяет, является ли вторая строка подстрокой первой.

*Параметры*:
- #param("str1") — строка для поиска.
- #param("str2") — искомая подстрока.

*Возвращаемое значение*:
`1` если подстрока найдена, `0` если нет.

#line(stroke: 1pt, length: 100%)

//--------------------------------------------------------------------------------------

=== Файл filemanip.cpp

*Глобальные константы*:
- #param("MAX_FILES = 100") — максимальное количество обрабатываемых файлов
- #param("MAX_FILENAME_LENGTH = 256") — максимальная длина имени файла

*Функции работы с файлами*:

```cpp
FILE* openFile(const char* file_name, const char* operation);
```
*Описание* \
Безопасно открывает файл с обработкой ошибок.

*Параметры*:
- #param("file_name") — имя файла
- #param("operation") — режим открытия ("r", "w" и т.д.)

*Возвращает*:
Указатель на FILE или NULL при ошибке

#line(stroke: 1pt, length: 100%)

```cpp
void checkPath(const char* path);
```
*Описание* \
Проверяет и создает директорию при необходимости (кроссплатформенная реализация).

*Особенности*:
- Для Windows использует `_access` и `_mkdir`
- Для Linux использует системную команду `mkdir`

#line(stroke: 1pt, length: 100%)

```cpp
const char** listFilesInDirectory(const char* directory, int* fileCount);
```
*Описание* \
Получает список файлов в указанной директории.

#line(stroke: 1pt, length: 100%)

```cpp
int countFiles(const char* dir_name, const char* name);
```
*Описание* \
Подсчитывает файлы, содержащие подстроку в имени.

#line(stroke: 1pt, length: 100%)

```cpp
int fileExists(const char* path, const char* name, const char* extension, int max_size);
```
*Описание* \
Проверяет существование файла по полному пути.

*Параметры*:
- #param("path") — путь к директории
- #param("name") — имя файла
- #param("extension") — расширение файла
- #param("max_size") — максимальный размер полного пути

#line(stroke: 1pt, length: 100%)

```cpp
const char* extractFileName(const char* path);
```
*Описание* \
Извлекает имя файла из полного пути (последний компонент после '/').

#line(stroke: 1pt, length: 100%)

=== Файл menu.cpp

*Глобальные переменные*:  
- #param("MENU_TOP_INSTRUCTIONS_TOTAL") — количество инструкций в верхней части меню (значение: 2).  
- #param("MENU_BOTTOM_INSTRUCTIONS_TOTAL") — количество инструкций в нижней части меню (значение: 1).  
- #param("LIST_TOP_INSTRUCTIONS_TOTAL") — количество инструкций для списка (значение: 3).  
- #param("LIST_TOP_INSTRUCTIONS") — массив строк с инструкциями для списка.  
- #param("MENU_TOP_INSTRUCTIONS") — массив строк с инструкциями для меню.  
- #param("MENU_BOTTOM_INSTRUCTIONS") — массив строк с инструкциями для нижней части меню.  
- #param("MENU_WIDTH") — ширина меню для форматирования.  
- #param("MENU_MAX_LEN") — максимальная длина меню.  
- #param("menu_x, menu_y") — координаты курсора для позиционирования элементов меню.  
#line(stroke: 1pt, length: 100%)

```cpp
size_t utf8Strlen(const char *str);
```
*Описание* \  
Вычисляет длину строки с учётом UTF-8 символов (включая нелатинские символы).  

*Параметры*  
- #param("str") — строка для измерения.  

*Возвращаемое значение* \  
Длина строки в символах.  
#line(stroke: 1pt, length: 100%)

```cpp
void wait();
```
*Описание* \  
Приостанавливает выполнение программы и ожидает нажатия любой клавиши, уведомляя пользователя.  
#line(stroke: 1pt, length: 100%)

```cpp
void info(const char **messages, int num_of_messages, FILE *stream);
```
*Описание* \  
Выводит массив строк вертикально в указанный поток (по умолчанию — `stdout`).  

*Параметры*  
- #param("messages") — массив строк для вывода.  
- #param("num_of_messages") — количество строк в массиве.  
- #param("stream") — указатель на поток вывода.  
#line(stroke: 1pt, length: 100%)

```cpp
int printStringsVertically(int y, const char **str, int str_total);
```
*Описание* \  
Выводит массив строк вертикально, начиная с указанной позиции `y`.  

*Параметры*  
- #param("y") — начальная позиция по вертикали.  
- #param("str") — массив строк для вывода.  
- #param("str_total") — количество строк в массиве.  

*Возвращаемое значение* \  
Новая позиция по вертикали после вывода.  
#line(stroke: 1pt, length: 100%)

```cpp
int printInfo(int y, const char **top_mes, const char **bottom_mes, int top_mes_total, int bottom_mes_total);
```
*Описание* \  
Выводит инструкции для меню или списка, включая разделители.  

*Параметры*  
- #param("y") — начальная позиция по вертикали.  
- #param("top_mes") — массив строк верхних инструкций.  
- #param("bottom_mes") — массив строк нижних инструкций.  
- #param("top_mes_total") — количество верхних инструкций.  
- #param("bottom_mes_total") — количество нижних инструкций.  

*Возвращаемое значение* \  
Позиция по вертикали для начала содержимого меню.  
#line(stroke: 1pt, length: 100%)

```cpp
void showList(const char *message, const char **options, int num_of_options);
```
*Описание* \  
Отображает список с заголовком, инструкциями и возможностью выбора.  

*Параметры*  
- #param("message") — заголовок списка.  
- #param("options") — массив строк (пунктов списка).  
- #param("num_of_options") — количество пунктов списка.  
#line(stroke: 1pt, length: 100%)

```cpp
int menu(const char *message, const char **options, int num_of_options);
```
*Описание* \  
Отображает меню с заголовком, инструкциями и возможностью выбора пункта.  

*Параметры*  
- #param("message") — заголовок меню.  
- #param("options") — массив строк (пунктов меню).  
- #param("num_of_options") — количество пунктов меню.  

*Возвращаемое значение* \  
Индекс выбранного пункта меню.  
#line(stroke: 1pt, length: 100%)

=== Файл decorators.cpp

```cpp
void getWindowCenter(int width);
```
*Описание* \  
Вычисляет центральное положение окна консоли для корректного отображения меню.  

*Параметры*  
- #param("width") — ширина элемента, для которого вычисляется центр.  

*Особенности* \  
Реализация зависит от ОС: использует WinAPI для Windows и `ioctl` для Linux.  
#line(stroke: 1pt, length: 100%)

```cpp
void setCursorPosition(int x, int y);
```
*Описание* \  
Устанавливает позицию курсора в консоли по заданным координатам.  

*Параметры*  
- #param("x") — горизонтальная координата.  
- #param("y") — вертикальная координата.  
#line(stroke: 1pt, length: 100%)

```cpp
void clearBox(int y);
```
*Описание* \  
Очищает прямоугольную область консоли, начиная с указанной позиции `y`.  

*Параметры*  
- #param("y") — начальная вертикальная позиция.  
#line(stroke: 1pt, length: 100%)

```cpp
void clearLinesDownFrom(int x, int y, int lines);
```
*Описание* \  
Очищает указанное количество строк консоли, начиная с заданных координат.  

*Параметры*  
- #param("x") — начальная горизонтальная позиция.  
- #param("y") — начальная вертикальная позиция.  
- #param("lines") — количество очищаемых строк.  
#line(stroke: 1pt, length: 100%)

```cpp
int inputBox(const char *title, char *buf, void (*conditions[])(struct entry *), char frame);
```
*Описание* \  
Создаёт интерактивное поле ввода с рамкой, заголовком и инструкциями.  

*Параметры*  
- #param("title") — заголовок поля ввода.  
- #param("buf") — буфер для хранения введённых данных.  
- #param("conditions") — массив функций для проверки ввода.  
- #param("frame") — символ для оформления рамки.  

*Возвращаемое значение* \  
Длина введённой строки или `-1` при отмене.  
#line(stroke: 1pt, length: 100%)

```cpp
void drawSeparator(int y, char frame_char);
```
*Описание* \  
Рисует горизонтальную разделительную линию из указанного символа.  

*Параметры*  
- #param("y") — вертикальная позиция линии.  
- #param("frame_char") — символ для рисования линии.  
#line(stroke: 1pt, length: 100%)

```cpp
int printHeading(const char *str, char frame_char);
```
*Описание* \  
Выводит заголовок меню в рамке из указанного символа.  

*Параметры*  
- #param("str") — текст заголовка.  
- #param("frame_char") — символ для оформления рамки.  

*Возвращаемое значение* \  
Вертикальная позиция после вывода заголовка.  
#line(stroke: 1pt, length: 100%)

=== Файл input.cpp

*Структуры:*

```cpp
struct entry {
  int indent;   // Отступ от рамки
  int byte_pos; // Позиция в байтах
  int char_pos; // Позиция в символах (для курсора)
  int ch;       // Введенный символ
  int x;        // Положение курсора по горизонтали
  int y;        // Положение курсора по вертикали
  int max_len;  // Максимальная длина вводимой строки
  char *buf;    // Указатель на введённую строку
};
```

*Глобальные переменные*:  
- #param("INPUT_LENGTH") — максимальная длина вводимой строки.  
#line(stroke: 1pt, length: 100%)

```cpp
struct entry *initEntry(int y, char *buf);
```
*Описание* \  
Инициализирует структуру `entry` для управления вводом текста.  

*Параметры*  
- #param("y") — вертикальная позиция поля ввода.  
- #param("buf") — буфер для хранения введённых данных.  

*Возвращаемое значение* \  
Указатель на созданную структуру или `NULL` при ошибке выделения памяти.  
#line(stroke: 1pt, length: 100%)

```cpp
int cgetch();
```
*Описание* \  
Кроссплатформенная реализация функции `getch()` для чтения символов без эха.  

*Возвращаемое значение* \  
Символ, введённый пользователем.  
#line(stroke: 1pt, length: 100%)

```cpp
int checkSystemKeys(struct entry *properties);
```
*Описание* \  
Проверяет, является ли введённый символ системной клавишей (навигация, F-клавиши и т.д.).  

*Параметры*  
- #param("properties") — указатель на структуру `entry` с информацией о вводе.  

*Возвращаемое значение* \  
`0`, если символ является системной клавишей, иначе `1`.  
#line(stroke: 1pt, length: 100%)

```cpp
void checkFileExists(struct entry *properties);
```
*Описание* \  
Проверяет существование файла с введённым названием и выводит предупреждение при совпадении.  

*Параметры*  
- #param("properties") — указатель на структуру `entry` с буфером ввода.  
#line(stroke: 1pt, length: 100%)

```cpp
void handleRestrictedSymbols(struct entry *properties);
```
*Описание* \  
Обрабатывает ввод запрещённых символов, выводя сообщение об ошибке.  

*Параметры*  
- #param("properties") — указатель на структуру `entry`.  
#line(stroke: 1pt, length: 100%)

```cpp
void handleAllowedSymbols(struct entry *properties);
```
*Описание* \  
Обрабатывает разрешённые символы, включая UTF-8 (кириллицу), и добавляет их в буфер.  

*Параметры*  
- #param("properties") — указатель на структуру `entry`.  
#line(stroke: 1pt, length: 100%)

```cpp
void handleFileNameRestrictedSymbols(struct entry *properties);
```
*Описание* \  
Обрабатывает ввод запрещённых символов для имени файла. Проверяет каждый введённый символ на соответствие допустимому набору (латинские буквы и цифры), а также блокирует системные клавиши. При обнаружении недопустимого символа выводит предупреждающее сообщение.

*Параметры*  
- #param("properties") — указатель на структуру `entry`.  
#line(stroke: 1pt, length: 100%)


```cpp
void handleFileNameAllowedSymbols(struct entry *properties);
```
*Описание* \  
Обрабатывает разрешённые символы для имени файла. Добавляет в буфер только латинские буквы и цифры (ASCII-символы), игнорируя пробелы, кириллицу и специальные символы. Также проверяет ограничение длины буфера.

*Параметры*  
- #param("properties") — указатель на структуру `entry`.
#line(stroke: 1pt, length: 100%)

```cpp
void handleBACK_SPACE(struct entry *properties);
```
*Описание* \  
Обрабатывает удаление символов (Backspace), включая корректную работу с UTF-8.  

*Параметры*  
- #param("properties") — указатель на структуру `entry`.  
#line(stroke: 1pt, length: 100%)

```cpp
int strInput(char *buf, int y, void (*conditions[])(struct entry *));
```
*Описание* \  
Управляет процессом ввода строки с обработкой клавиш и дополнительными условиями.  

*Параметры*  
- #param("buf") — буфер для хранения введённых данных.  
- #param("y") — вертикальная позиция поля ввода.  
- #param("conditions") — массив функций для проверки ввода (завершается `NULL`).  

*Возвращаемое значение* \  
Длина введённой строки или `-1` при отмене ввода (TAB).  
#line(stroke: 1pt, length: 100%)

=== Файл options.cpp

*Структуры:*

```cpp 
struct menu {
  int variant;          // Выбранный пункт
  int scroll_offset;    // Смещение видимой части списка опций
  int ch;               // Номер нажатой клавиши
  int cursor_y;         // Положение курсора
  int y;                // Положение меню по вертикали
  const char **options; // массив пунктов меню
  int num_of_options;   // количество пунктов меню
  int choose;           // номер выбранного пункта
  int visible_items;    // количество видимых пунктов
};
```

*Глобальные массивы*:
- #param("main_options_handlers") — массив обработчиков для основного меню (навигация вверх/вниз).
- #param("list_options_handlers") — массив обработчиков для списка (навигация + сортировка).

#line(stroke: 1pt, length: 100%)

```cpp
void scroll(int index, int y, const char **options, int num_of_options);
```
*Описание* \
Выводит видимую часть списка опций меню с учётом текущего смещения.

*Параметры*:
- #param("index") — начальный индекс для отображения.
- #param("y") — вертикальная позиция вывода.
- #param("options") — массив строк-опций.
- #param("num_of_options") — общее количество опций.

#line(stroke: 1pt, length: 100%)

```cpp
int hibbardStep(int n, int i);
```
*Описание* \
Вычисляет шаг для сортировки методом Шелла (последовательность Хиббарда).

*Параметры*:
- #param("n") — количество элементов.
- #param("i") — номер итерации.

*Возвращаемое значение*:
Длина шага для текущей итерации.

#line(stroke: 1pt, length: 100%)

```cpp
void sorter(const char **arr, int n, const int order);
```
*Описание* \
Сортирует массив строк методом Шелла.

*Параметры*:
- #param("arr") — массив строк.
- #param("n") — количество элементов.
- #param("order") — направление сортировки (1 — по возрастанию, 0 — по убыванию).

#line(stroke: 1pt, length: 100%)

```cpp
struct menu *initMenu(int y, int num_of_options, const char **options);
```
*Описание* \
Инициализирует структуру управления меню.

*Параметры*:
- #param("y") — начальная вертикальная позиция.
- #param("num_of_options") — количество опций.
- #param("options") — массив строк-опций.

*Возвращаемое значение*:
Указатель на структуру `menu` или `NULL` при ошибке.

#line(stroke: 1pt, length: 100%)

```cpp
void handleAscSort(struct menu *params);
```
*Описание* \
Обрабатывает сортировку по возрастанию (клавиша 'a').

*Параметры*:
- #param("params") — указатель на структуру меню.

#line(stroke: 1pt, length: 100%)

```cpp
void handleDescSort(struct menu *params);
```
*Описание* \
Обрабатывает сортировку по убыванию (клавиша 'd').

*Параметры*:
- #param("params") — указатель на структуру меню.

#line(stroke: 1pt, length: 100%)

```cpp
void handleDown(struct menu *params);
```
*Описание* \
Обрабатывает нажатие стрелки вниз (перемещение по меню).

*Параметры*:
- #param("params") — указатель на структуру меню.

#line(stroke: 1pt, length: 100%)

```cpp
void handleUp(struct menu *params);
```
*Описание* \
Обрабатывает нажатие стрелки вверх (перемещение по меню).

*Параметры*:
- #param("params") — указатель на структуру меню.

#line(stroke: 1pt, length: 100%)

```cpp
void drawCursor(struct menu *params, int clear);
```
*Описание* \
Отрисовывает или скрывает курсор меню.

*Параметры*:
- #param("params") — указатель на структуру меню.
- #param("clear") — флаг очистки (1 — скрыть, 0 — отобразить).

#line(stroke: 1pt, length: 100%)

```cpp
int getOption(int y, const char **options, int num_of_options, int choose, void (*handlers[])(struct menu *));
```
*Описание* \
Управляет процессом выбора пункта меню с обработкой навигации и дополнительных действий.

*Параметры*:
- #param("y") — вертикальная позиция меню.
- #param("options") — массив строк-опций.
- #param("num_of_options") — количество опций.
- #param("choose") — клавиша подтверждения выбора (например, `ENTER`).
- #param("handlers") — массив обработчиков клавиш.

*Возвращаемое значение*:
Индекс выбранного пункта (начиная с 1) или `-1` при отмене.

#pagebreak()

//-------------------------------------------------------------------------------------

= Инструкция пользователя

== Общий обзор приложения

Приложение предназначено для управления учебными данными: создания, редактирования, сохранения и загрузки расписаний с возможностью добавления предметов и форм контроля.

== Интерфейс и навигация
*Навигация по меню*

    - Перемещение между пунктами: клавиши "стрелка вверх" и "стрелка вниз"
    - Выбор пункта: клавиша Enter
    - Выход/отмена: клавиша Tab
    - Курсор отображается как "-->"

*Особенности ввода*

    - Поддержка кириллических символов
    - Ограничение на длину вводимых данных
    - Проверка корректности вводимых символов
    - Возможность удаления символов клавишей Backspace

*Доступные формы контроля:*

    - Экзамен
    - Зачёт
    - Контрольная работа (КР)
    - Курсовой проект (КП)
    - Контрольная
    - Рейтинг

== Создание расписания с нуля
*Шаги создания:*

  В главном меню выберите "Создать новое расписание"

  #pict("docs/img/250814_14h00m26s_screenshot.png")

  *Добавление предметов:*
      + Выберите "Добавить предмет"     #pict("docs/img/250813_09h47m00s_screenshot.png")
      + Введите название предмета       #pict("docs/img/250814_14h02m30s_screenshot.png")
      + Система подтвердит добавление   #pict("docs/img/250813_09h50m35s_screenshot.png")

  *Добавление форм контроля:*
      + Выберите "Добавить форму контроля"  #pict("docs/img/250813_09h54m34s_screenshot.png")
      + Выберите предмет                    #pict("docs/img/250814_14h03m58s_screenshot.png")
      + Выберите тип контроля из списка     #pict("docs/img/250815_12h17m00s_screenshot.png")
      + Система подтвердит добавление       #pict("docs/img/250813_09h56m36s_screenshot.png")

== Загрузка расписания из файла
*Процесс загрузки:*

    + В главном меню выберите "Загрузить расписание из файла" #pict("docs/img/250813_09h43m02s_screenshot.png")
    + Выберите файл из папки txt                              #pict("docs/img/250813_09h44m37s_screenshot.png")
    + Система загрузит предметы и формы контроля
    + Можно продолжить редактирование загруженного расписания #pict("docs/img/250813_09h47m00s_screenshot.png")

*Требования к файлу:*

- Текстовый формат .txt
- Структура: Предмет Форма_контроля1 Форма_контроля2 ...
- Пример: Математика Экзамен КР Зачёт

== Редактирование расписания
*Доступные операции:*
    === Добавить предмет
      #pict("docs/img/250813_09h47m00s_screenshot.png")
      #pict("docs/img/250813_09h50m02s_screenshot.png")
    === Удалить предмет
      #pict("docs/img/250813_10h08m32s_screenshot.png")
      #pict("docs/img/250813_09h55m50s_screenshot.png")
      #pict("docs/img/250813_10h09m22s_screenshot.png")
    === Добавить форму контроля
      #pict("docs/img/250813_09h54m34s_screenshot.png")
      #pict("docs/img/250813_09h55m50s_screenshot.png")
      #pict("docs/img/250813_09h56m36s_screenshot.png")
    === Удалить форму контроля
      #pict("docs/img/250813_10h05m58s_screenshot.png")
      #pict("docs/img/250813_09h55m50s_screenshot.png")
      #pict("docs/img/250813_10h07m14s_screenshot.png")
    === Просмотр структуры расписания
      #pict("docs/img/250815_17h36m42s_screenshot.png")
      #pict("docs/img/250813_09h57m55s_screenshot.png")
      #pict("docs/img/250815_17h37m10s_screenshot.png")
      #pict("docs/img/250815_17h37m29s_screenshot.png")
    === Поиск по форме контроля
      #pict("docs/img/250903_20h36m01s_screenshot.png")
      #pict("docs/img/250903_20h37m43s_screenshot.png")

== Сохранение расписания
*Варианты сохранения:*
  
  В главном меню и в меню операций после загрузки расписания из файла или создания с нуля
появится пункт "Сохранить". В зависимости от способа создания расписания варианты сохранения будут отличаться (см. диаграмму ниже).

#let bent-edge(from, to, ..args) = {
  let midpoint = (from, 50%, to)
  let vertices = (
    from,
    (from, "|-", midpoint),
    (midpoint, "-|", to),
    to,
  )
  edge(..vertices, "-|>", ..args)
}

#diagram(
  node-stroke: luma(80%),
  edge-corner-radius: none,
  spacing: (10pt, 20pt),

  // Nodes
  node((1,0), [*Сохранить*], name: <a>),

  node((0,2), [*Расписание \ загружено \ из одного файла*], name: <b>),
  node((1,2), [*Расписание \ загружено \ из нескольких \ файлов*], name: <e>),
  node((2,2), [*Расписание \ создано с \ нуля*], name: <c>),

  node((0,3), [*Сохранить \ в исходный файл \ или \ в новый файл*], name: <d>),
  node((1.5,3), [*Сохранить в новый файл*], name: <f>),

  // Edges
  edge(<a>, <e>),
  bent-edge(<a>, <c>),
  bent-edge(<a>, <b>),
  edge(<b>, <d>),
  edge(<e>, <f>),
  edge(<c>, <f>),
)

  Чтобы сохранить изменения выберите пункт "Сохранить" в главном меню или в меню операций
    #pict("docs/img/250815_17h12m05s_screenshot.png")
    Или
    #pict("docs/img/250813_10h01m08s_screenshot.png")

  Если расписание изначально загружено из одного файла, программа предложит выбрать способ сохранения.

  1. Чтобы сохранить изменения в файл, из которого было загружено расписание, выберите пункт 1.
    #pict("docs/img/250813_10h01m59s_screenshot.png")
  + Сразу после сохранения программа уведомит о завершении операции.
    #pict("docs/img/250813_10h02m44s_screenshot.png")

  1. Чтобы сохранить изменения в новый файл, выберите пункт 2.
    #pict("docs/img/250813_10h03m06s_screenshot.png")
  + Введите название файла #pict("docs/img/250813_10h04m43s_screenshot.png")
  + Сразу после сохранения программа уведомит о завершении операции.
    #pict("docs/img/250813_10h05m10s_screenshot.png")
  
  Если расписание было загружено из нескольких файлов или создано с нуля, сохранение будет доступно только в новый файл.

    + Введите название файла                                                            #pict("docs/img/250814_14h12m31s_screenshot.png")
    + После подтверждения ввода программа сохранит расписание новый файл в папке txt    #pict("docs/img/250813_10h05m10s_screenshot.png")

*Автоматическое предложение сохранения*
  - При наличии несохраненных изменений
  - При выходе из приложения

== Очистка расписания

    + В главном меню выберите "Очистить текущее расписание" #pict("docs/img/250814_14h30m09s_screenshot.png")
    + Подтвердите действие                                  #pict("docs/img/250814_14h30m28s_screenshot.png")
    + Все предметы и формы контроля будут удалены           #pict("docs/img/250814_14h31m07s_screenshot.png")

== Поиск
*Функция поиска предметов*

    + Выберите "Поиск по форме контроля"                #pict("docs/img/250903_20h36m01s_screenshot.png")
    + Введите часть названия формы контроля            
      #pict("docs/img/250903_20h37m43s_screenshot.png")
    + Система выведет найденные совпадения

== Клавиши управления

#table(
  columns: (auto, 1fr),
  stroke: none,
  // Заголовки столбцов
  [*Клавиша*], [*Действие*],
  // Содержимое таблицы
  [`↑/↓`], [Навигация по меню],
  [`Enter`], [Выбор/подтверждение],
  [`Tab`], [Отмена/возврат],
  [`Backspace`], [Удаление символа],
  [`a`], [Сортировка по возрастанию (только для операции "Просмотреть расписание")],
  [`d`], [Сортировка по убыванию (только для операции "Просмотреть расписание")],
)

= Листинг

== main.cpp
#listing("main.cpp")

== constants.h 
#listing("include/constants.h")

== stdmanip.h
#listing("include/stdmanip.h")

== stdmanip.cpp
#listing("src/stdmanip.cpp")

== filemanip.h
#listing("include/filemanip.h")

== filemanip.cpp
#listing("src/filemanip.cpp")

== menu.h
#listing("include/menu/menu.h")

== menu.cpp
#listing("src/menu/menu.cpp")

== option.h
#listing("include/menu/options.h")

== option.cpp
#listing("src/menu/options.cpp")

== input.h
#listing("include/menu/input.h")

== input.cpp
#listing("src/menu/input.cpp")

== decorators.h
#listing("include/menu/decorators.h")

== decorators.cpp
#listing("src/menu/decorators.cpp")

= Тестирование 

== Среда тестирования

  - Операционная система: [Windows 10/Arch Linux/Ubuntu 24.04 LTS]
  - Используемые инструменты: 
    - компилятор: gcc version 15.1.1 20250729 (GCC), 
    - дебаггер: GNU gdb (GDB) 16.3.

== Добавление предметов

  === Первый элемент
    - *Корректность отображения интерфейса:* 
      - Интерфейс для ввода имени предмета отображается по центру экрана, рамка и заголовок ("Предмет") видны, поле ввода пустое. 
      - Инструкция ("Enter - подтвердить, TAB - отмена") хорошо видна и понятна.
    - *Корректная обработка нажатий:*
      - Ввод буквенно-цифровых символов и кириллицы: символы отображаются в поле ввода корректно.
      - Backspace: удаляет последний символ.
      - Enter: подтверждает ввод.
      - Tab: отменяет ввод.
      - Запрещённые символы (пунктуация, пробелы) не добавляются в строку, появляется сообщение "Недопустимые символы".
    - *Функциональность:* После ввода имени и нажатия Enter, новый предмет успешно добавляется в пустой список.
        #pict("docs/img/250814_14h02m30s_screenshot.png")
        #pict("docs/img/250813_09h50m35s_screenshot.png")
    - *Обработка граничных условий:*
        - Пустое имя: предмет не создается с пустым названием.
        - Максимальная длина (31 символ): ввод более длинной строки обрезается, что предотвращает переполнение буфера.
        #pict("docs/img/250817_12h08m08s_screenshot.png")
    - *Вывод:* 
          - Ожидаемый результат: После успешного добавления отображается сообщение "Предмет успешно добавлен!", предмет появляется в связном списке.
          - Фактический результат: Совпал с ожидаемым.


  === Добавление к уже существующему
        - *Корректность отображения интерфейса:* Аналогично п. 6.2.1. Интерфейс отображается корректно.
        - *Корректная обработка нажатий:* Аналогично п. 6.2.1. Все клавиши ввода и управления работают стабильно.
        - *Функциональность:* Новый предмет добавляется в конец существующего списка предметов.
        #pict("docs/img/250817_12h10m03s_screenshot.png")
        #pict("docs/img/250813_09h50m35s_screenshot.png")
        #pict("docs/img/250817_12h15m54s_screenshot.png")
        - *Обработка граничных условий:*
            - Повторяющееся имя: Программа не предотвращает добавление предметов с одинаковыми именами.
        - *Вывод:*
          - Ожидаемый результат: После успешного добавления отображается сообщение "Предмет успешно добавлен!".
          - Фактический результат: Совпал с ожидаемым.

== Добавление форм контроля

    === Первый элемент
        - *Корректность отображения интерфейса:* Сначала отображается меню выбора предмета. После выбора предмета, появляется меню выбора формы контроля ("Выберите форму контроля для [Имя предмета]"), список форм контроля отображается корректно, с возможностью навигации с помощью стрелкок.
        #pict("docs/img/250813_09h54m34s_screenshot.png")
        #pict("docs/img/250814_14h25m58s_screenshot.png")
        #pict("docs/img/250815_12h17m00s_screenshot.png")
        #pict("docs/img/250814_14h07m35s_screenshot.png")
        - *Корректная обработка нажатий:*
            - Стрелки (↑, ↓): перемещают курсор по списку.
            - Enter: выбирает форму контроля.
            - Tab: отменяет выбор и возвращает в предыдущее меню.
        - *Функциональность:* Выбранная форма контроля успешно добавляется к выбранному предмету.
        - *Обработка граничных условий:*
            - Отсутствие предметов: Если предметов нет, выводится сообщение "В этой структуре пока нет предметов...", и операция отменяется.
            #pict("docs/img/250814_14h01m42s_screenshot.png")
            - Дублирование форм контроля: Программа позволяет добавить несколько одинаковых форм контроля к одному предмету (например, два "Экзамена").
        - *Вывод:*
            - Ожидаемый результат: После успешного добавления отображается сообщение "Форма контроля успешно добавлена!", выбранная форма контроля появляется в конце списка указанного предмета.
            - Фактический результат: Совпал с ожидаемым.

    === Добавление к уже существующему
        - *Корректность отображения интерфейса:* Аналогично п. 2.1.
        - *Корректная обработка нажатий:* Аналогично п. 2.1.
        - *Функциональность:* Новая форма контроля добавляется к списку форм контроля выбранного предмета.
        #pict("docs/img/250814_14h25m58s_screenshot.png")
        #pict("docs/img/250817_12h03m22s_screenshot.png")
        #pict("docs/img/250817_12h03m56s_screenshot.png")
        - *Обработка граничных условий:* Аналогично п. 6.3.1., включая возможность дублирования.
        - *Вывод:*
            - Ожидаемый результат: После успешного добавления отображается сообщение "Форма контроля успешно добавлена!", выбранная форма контроля появляется в конце списка указанного предмета.
            - Фактический результат: Совпал с ожидаемым.

== Просмотр расписания
    === Просмотр
        - *Корректность отображения интерфейса:* Отображается заголовок "Просмотр структуры проекта". Список предметов и их форм контроля выводится вертикально, каждый предмет с его формами контроля в одной строке. Инструкции для просмотра и сортировки ("Просмотр с помощью клавиш ↑ и ↓", "Для сортировки по возрастанию нажмите а", "Для сортировки по убыванию нажмите d") отображаются.
        - *Корректная обработка нажатий:*
            - Стрелки (↑, ↓): корректно прокручивают список, если он не помещается в меню.
            - Tab: возвращает в меню операций.
        - *Функциональность:* Все добавленные предметы и их формы контроля отображаются в виде списка.
        #pict("docs/img/250815_17h37m29s_screenshot.png")
        - *Обработка граничных условий:*
        #pict("docs/img/250814_14h01m42s_screenshot.png")
            - Пустой список: Если предметов нет, выводится сообщение "В этой структуре пока нет предметов...".
        - *Вывод:*
            - Ожидаемый результат: Полная и корректно отформатированная структура предметов и форм контроля.
            - Фактический результат: Совпал с ожидаемым.

    === Сортировка
        - *Корректность отображения интерфейса:* Список предметов перерисовывается после сортировки, сохраняя форматирование.
        - *Корректная обработка нажатий:*
            - 'a': сортирует список предметов по возрастанию (алфавитный порядок).
            #pict("docs/img/250815_17h37m10s_screenshot.png")
            - 'd': сортирует список предметов по убыванию (обратный алфавитный порядок).
            #pict("docs/img/250815_17h37m29s_screenshot.png")
        - *Функциональность:* Сортировка по имени предмета работает корректно в обоих направлениях. Формы контроля остаются привязанными к своим предметам.
        - *Обработка граничных условий:*
            - Сортировка списка из одного элемента: Не вызывает ошибок, список остаётся неизменным.
        - *Вывод:*
            - Ожидаемый результат: Список предметов отсортирован в соответствии с выбранным порядком.
            - Фактический результат: Совпал с ожидаемым.

== Поиск
    - *Корректность отображения интерфейса:* Поле ввода отображается с заголовком "Форма контроля" по центру экрана, результаты поиска отображаются под полем ввода.
    - *Корректная обработка нажатий:*
        - Ввод символов: динамически обновляет результаты поиска.
        - Backspace: динамически обновляет результаты поиска.
        - Tab и Enter возвращают в меню операций.
    - *Функциональность:* При вводе символов в поле, программа динамически ищет предметы, формы контроля которых содержат введённую подстроку, и отображает их под полем ввода. #pict("docs/img/250903_20h37m43s_screenshot.png")
    - *Обработка граничных условий:*
        - Пустая строка поиска: Выводится сообщение "Ничего не найдено...".
        - Нет совпадений: Выводится сообщение "Ничего не найдено...". #pict("docs/img/250903_20h38m23s_screenshot.png")
        - Поиск в пустом расписании: Не вызывает ошибок, выводится "Ничего не найдено...".
    - *Вывод:*
        - Ожидаемый результат: Список найденных предметов (и их форм контроля) отображается под полем ввода, обновляясь по мере ввода.
        - Фактический результат: Совпал с ожидаемым.

== Сохранение

    === Расписание было загружено из одного файла
        - *Корректность отображения интерфейса:* Меню "Сохранить как" предлагает два варианта: "Сохранить изменения в [имя файла]" и "Сохранить в новый файл".
        - *Корректная обработка нажатий:* Выбор опций (1, 2) и отмена (Tab) работают корректно.
        #pict("docs/img/250817_15h07m17s_screenshot.png")
        - *Функциональность:*
            - Выбор "Сохранить в исходный файл": данные текущего расписания перезаписывают исходный файл.
        #pict("docs/img/250813_10h01m59s_screenshot.png")
        #pict("docs/img/250813_10h02m44s_screenshot.png")
            - Выбор "Сохранить в новый файл": открывается поле для ввода имени нового файла, в который сохраняется расписание.
        #pict("docs/img/250813_10h03m06s_screenshot.png")
        #pict("docs/img/250813_10h04m43s_screenshot.png")
        #pict("docs/img/250813_10h05m10s_screenshot.png")
        - *Обработка граничных условий:*
            Ошибки записи (например, нет прав): Выводится сообщение "Файл не удалось сохранить...".
        - *Вывод:*
            - Ожидаемый результат: Сообщение "Изменения успешно сохранены!" или "Файл успешно сохранен в папку txt".
            - Фактический результат: Совпал с ожидаемым.

    === Расписание было загружено из нескольких файлов
        - *Корректность отображения интерфейса:* Аналогично п. 6.6.1.
        - *Корректная обработка нажатий:* Аналогично п. 6.6.1.
        - *Функциональность:* При попытке сохранить изменения, когда расписание было сформировано из нескольких файлов, программа всегда предлагает сохранить в новый файл.
        - *Обработка граничных условий:* Аналогично п. 6.6.1.
        - *Вывод:*
            - Ожидаемый результат: Предложение сохранить в новый файл, затем сообщение об успешном сохранении в новый файл.
            - Фактический результат: Совпал с ожидаемым.

    === Расписание было создано с нуля
        - *Корректность отображения интерфейса:* При выборе сохранения, программа сразу предлагает сохранить в новый файл.
        - *Корректная обработка нажатий:* Аналогично п. 5.1.
        - *Функциональность:* Расписание сохраняется в новый файл с указанным именем.
        - *Обработка граничных условий:* Аналогично п. 5.1. Проверка на существование файла с таким именем реализована.
        - *Вывод:*
            - Ожидаемый результат: Сообщение "Файл успешно сохранен!".
            - Фактический результат: Совпал с ожидаемым.

== Удаление форм контроля
    - *Корректность отображения интерфейса:* Сначала отображается меню выбора предмета. После выбора предмета, отображается меню выбора формы контроля для удаления.
    - *Корректная обработка нажатий:*
        - Стрелки (↑, ↓): перемещают курсор.
        - Enter: выбирает форму контроля для удаления.
        - Tab: отменяет операцию.
    - *Функциональность:* Выбранная форма контроля успешно удаляется из списка форм контроля соответствующего предмета. Флаги changes и saved обновляются.
    #pict("docs/img/250822_15h32m51s_screenshot.png", cap: "исходный список")
    #pict("docs/img/250822_15h33m31s_screenshot.png")
    #pict("docs/img/250822_15h33m57s_screenshot.png")
    #pict("docs/img/250822_15h35m39s_screenshot.png")
    #pict("docs/img/250822_15h38m09s_screenshot.png")
    #pict("docs/img/250822_15h39m06s_screenshot.png")
    #pict("docs/img/250822_15h41m05s_screenshot.png")
    #pict("docs/img/250822_15h41m22s_screenshot.png")
    #pict("docs/img/250822_15h41m46s_screenshot.png")
    - *Обработка граничных условий:*
        - Нет форм контроля у предмета: Выводится сообщение: "У этого предмета пока не указаны формы контроля".
        #pict("docs/img/250817_12h13m48s_screenshot.png")
    - *Вывод:*
        - Ожидаемый результат: выбранная для удаления форма контроля пропадает из списка.
        - Фактический результат: Совпал с ожидаемым.

== Удаление предметов
    - *Корректность отображения интерфейса:* Отображается меню выбора предмета для удаления.
    - *Корректная обработка нажатий:*
        - Стрелки (↑, ↓): перемещают курсор.
        - Enter: выбирает предмет для удаления.
        - Tab: отменяет операцию.
    - *Функциональность:* Выбранный предмет и все его формы контроля успешно удаляются из списка.
    #pict("docs/img/250822_15h23m57s_screenshot.png")
    #pict("docs/img/250822_15h24m42s_screenshot.png")
    #pict("docs/img/250822_15h26m08s_screenshot.png")
    #pict("docs/img/250822_15h27m28s_screenshot.png")
    #pict("docs/img/250822_15h27m52s_screenshot.png")
    #pict("docs/img/250822_15h28m32s_screenshot.png")
    #pict("docs/img/250822_15h28m58s_screenshot.png")
    #pict("docs/img/250822_15h29m50s_screenshot.png")
    #pict("docs/img/250814_14h01m42s_screenshot.png")
    - *Обработка граничных условий:*
        - Нет предметов: Выводится сообщение "В этой структуре пока нет предметов...".
        - Удаление последнего предмета: Список становится пустым.
    - *Вывод:*
        - Ожидаемый результат: Сообщение "Предмет успешно удален!".
        - Фактический результат: Совпал с ожидаемым.

== Загрузка расписания из файла

        - *Корректность отображения интерфейса:* Меню "Выберите файл" отображает список файлов из директории "txt".
        #pict("docs/img/250813_09h44m37s_screenshot.png")
        - *Корректная обработка нажатий:* Навигация по списку файлов (стрелки) и выбор (Enter) работают корректно. Отмена (Tab) возвращает в главное меню.
        - *Функциональность:* Содержимое выбранного файла успешно считывается и парсится, создавая структуру предметов и форм контроля.
        #pict("docs/img/250813_09h57m55s_screenshot.png")
        #pict("docs/img/250817_15h11m11s_screenshot.png")
        - *Обработка граничных условий:*
            - Отсутствие файлов в директории "txt": Выводится соответствующее сообщение:
            #pict("docs/img/250822_18h53m35s_screenshot.png")
        - *Вывод:*
            - Ожидаемый результат: Данные из файла загружены, и программа переходит в меню операций.
            - Фактический результат: Совпал с ожидаемым.

== Совмещение расписания

        - *Корректность отображения интерфейса:* Меню выбора файла отображается корректно.
        - *Корректная обработка нажатий:* Стабильна.
        - *Функциональность:* Предметы из нового загруженного файла добавляются к уже существующим в памяти. Если предметы с такими же именами уже есть, они дублируются. Формы контроля также просто добавляются.
        #pict("docs/img/250817_22h39m31s_screenshot.png")
        #pict("docs/img/250817_22h39m56s_screenshot.png")
        #pict("docs/img/250817_22h35m30s_screenshot.png")
        #pict("docs/img/250817_22h37m37s_screenshot.png")
        - *Обработка граничных условий:* Потенциально может привести к дублированию данных.
        - *Вывод:*
            - Ожидаемый результат: Все предметы из нового файла добавлены к текущему списку.
            - Фактический результат: Совпал с ожидаемым.

== Автоматическое сохранение при выходе

    - *Корректность отображения интерфейса:* При попытке выйти из программы (нажатием Tab в главном меню), если есть несохранённые изменения, появляется диалог "Сохранить изменения?".
    - *Корректная обработка нажатий:*
        - Выбор "Да" (1): переходит к процессу сохранения (см. п. 6.6).
        - Выбор "Нет" (2): программа выходит без сохранения.
        - Tab: программа завершается, сохраняя расписание в файл "untitled.txt".
        #pict("docs/img/250822_19h58m52s_screenshot.png")
    - *Функциональность:* Программа корректно определяет наличие несохранённых изменений и предлагает их сохранить.
    - *Обработка граничных условий:*
        Нет изменений: Программа выходит без запроса сохранения.
    - *Вывод:*
        - Ожидаемый результат: Диалог сохранения появляется, если есть несохранённые изменения, и действует согласно выбору пользователя.
        - Фактический результат: Совпал с ожидаемым.

== Заключение

Программа демонстрирует стабильную работу основных функций по управлению учебными данными через консольный интерфейс. Отображение интерфейса и обработка нажатий реализованы качественно. Основная функциональность (добавление/удаление предметов и форм контроля, просмотр, поиск, сохранение/загрузка) работает, как ожидалось.

#pagebreak()
#set page(numbering: none)

== routes.h
#listing("include/routes.h")

== routes.cpp
#listing("src/routes.cpp")

