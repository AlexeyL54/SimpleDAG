#import "@preview/lovelace:0.3.0" : *
#import "@preview/codly:1.3.0": *
#import "@preview/codly-languages:0.1.1": *
#import "@preview/fletcher:0.5.8" as fletcher: diagram, node, edge
#import "@preview/big-todo:0.2.0": todo, todo_outline
#show: codly-init.with()

#set page(
  width: 210mm,
  height: 297mm,
  margin: 2.5cm,
  numbering: "1",
)

#set text(font: "BlexMono Nerd Font Mono")
#counter(page).update(1)
#set text(size: 14pt, lang: "ru")
#set heading(numbering: "1.")

#let param(string) = {
  highlight(
    fill: gray.lighten(70%),  // Серый цвет (можно настроить оттенок)
    radius: 4pt,              // Закругление углов
    [#string]                 // Выделяемый текст
  )
}

#let pict(path, cap: "") = {
  figure(
    image(path),
    caption: [#cap]
  )
}

#let listing(path) = {
  let listing = read(path)
  set text(size: 10pt)
  raw(listing, block: true, lang: "cpp")

}

#align(center)[

  #set text(size: 16pt)
  *
  МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ
  РОССИЙСКОЙ ФЕДЕРАЦИИ
  * \

  #v(1cm)
  *
  ФЕДЕРАЛЬНОЕ ГОСУДАРСТВЕННОЕ БЮДЖЕТНОЕ ОБРАЗОВАТЕЛЬНОЕ УЧРЕЖДЕНИЕ ВЫСШЕГО ОБРАЗОВАНИЯ \
  «МОСКОВСКИЙ АВИАЦИОННЫЙ ИНСТИТУТ
  (НАЦИОНАЛЬНЫЙ ИССЛЕДОВАТЕЛЬСКИЙ УНИВЕРСИТЕТ)»
  *

  #v(1cm)
  #set text(size: 16pt)
  Институт № 7 \
  «Робототехнические и интеллектуальные системы» \

  Кафедра 703 \
  «Системное проектирование авиакомплексов»

  #v(1cm)
  ОТЧЕТ №2 \
  о лабораторной работе по курсу\
  «Алгоритмы и структуры данных»
]

#v(2cm)

#align(right)[
  #box(width: 8cm, inset: 0pt, stroke: none)[
    Разработал: \
    Студент группы М70-306С-22 \
    Лапшин А. А. \ #underline("                           ")

    Принял:\
    Старший преподаватель кафедры 703 \
    Барчев Н. Б. \ #underline("                           ")
  ]
]

#align(bottom)[
  #align(center)[Москва, 2025]
]

#pagebreak()

// ------------------------------------------------------------------------------------
#set outline(
  title: [Содержание], // можно изменить название
  indent: 1em, // отступ для подразделов
)
#outline()
#pagebreak()
// ------------------------------------------------------------------------------------

#align(center)[
  #set text(size: 18pt)
  = Задание 
]

== Назначение проекта

Разработать программную систему — упрощенный аналог Apache Airflow для автоматической обработки табличных данных в формате CSV. Система должна обеспечивать построение направленного ациклического графа (DAG) операций и их последовательное выполнение над данными.

== Основные требования
- Конфигурация через YAML 
- Обработка табличных данных
- Графовое представление операций
- Логирование результатов
- C++ (стандарт C++17 или выше)
- Минимизация дублирования кода
- Соблюдение принципов SOLID
// ------------------------------------------------------------------------------------

#pagebreak()
// --------------------------------------------------------------------------------------

#align(center)[
  #set text(size: 18pt)
  = Сведения о программной реализации
]

== Язык программирования и среда разработки

Программа написана на языке программирования C++ (стандарт ISO/IEC
14882:2017) в среде разработки с открытым исходным кодом LazyVim
(готовая конфигурация NeoVim).

== Описание входных и выходных данных

*Входные данные*:
- конфигурационные файлы в фармате .yaml;
- таблицы в формате .csv;
- ввод с клавиатуры.

*Выходные данные*:
- логирование результата выполнения операций в текстовый файл;
- вывод в консоль.

== Программный интерфейс

=== Файл operations.cpp

*Глобальные переменные*:
- #param("map<string, FunctionVariant> operation_map") — словарь операций, сопоставляющий имена операций с их реализациями

#line(stroke: 1pt, length: 100%)

*Типы данных*:

```cpp
// Тип variant для хранения различных типов функций
using FunctionVariant = variant<
    function<float(vector<float>)>,
    function<string(vector<string>)>
>;
```

*Поддерживаемые операции в словаре*:

1. **sum** — вычисление суммы числовых значений
2. **average** — вычисление среднего арифметического числовых значений
3. **concatinate** — конкатенация строковых значений

#line(stroke: 1pt, length: 100%)

```cpp
float callOperation(const string &op_name, vector<float> arg);
```
*Описание* \
Вызывает числовую операцию из словаря операций.

*Параметры*:
- #param("op_name") — имя вызываемой операции
- #param("arg") — вектор числовых аргументов для операции

*Возвращаемое значение*: \
Результат выполнения операции в виде числа с плавающей точкой.

*Исключения*: \
- `runtime_error` если операция не найдена в словаре
- `runtime_error` если тип операции не соответствует числовому типу

#line(stroke: 1pt, length: 100%)

```cpp
string callOperation(const string &op_name, vector<string> arg);
```
*Описание* \
Вызывает строковую операцию из словаря операций.

*Параметры*:
- #param("op_name") — имя вызываемой операции
- #param("arg") — вектор строковых аргументов для операции

*Возвращаемое значение*: \
Результат выполнения операции в виде строки.

*Исключения*: \
- `runtime_error` если операция не найдена в словаре
- `runtime_error` если тип операции не соответствует строковому типу

#line(stroke: 1pt, length: 100%)

```cpp
float sum(vector<float> source);
```
*Описание* \
Вычисляет сумму всех элементов числового вектора.

*Параметры*:
- #param("source") — входной вектор числовых данных

*Возвращаемое значение*: \
Сумма всех элементов вектора.

*Сложность*: \
O(n), где n — количество элементов в векторе.

#line(stroke: 1pt, length: 100%)

```cpp
float average(vector<float> source);
```
*Описание* \
Вычисляет среднее арифметическое элементов числового вектора.

*Параметры*:
- #param("source") — входной вектор числовых данных

*Возвращаемое значение*: \
Среднее значение элементов вектора.

*Примечание*: \
Функция не проверяет, что вектор не пустой. Вызов с пустым вектором приведет к делению на ноль.

*Сложность*: \
O(n), где n — количество элементов в векторе.

#line(stroke: 1pt, length: 100%)

```cpp
string concatinate(vector<string> source);
```
*Описание* \
Объединяет все строки из вектора в одну строку (конкатенация).

*Параметры*:
- #param("source") — входной вектор строк

*Возвращаемое значение*: \
Результирующая объединенная строка.

*Примечание*: \
Для пустого вектора возвращается пустая строка.

*Сложность*: \
O(n × m), где n — количество строк, m — средняя длина строк.

// ------------------------------------------------------------------------------------

=== Файл graph.cpp

*Глобальные переменные*:
- #param("Node *first_head_ptr = nullptr") — указатель на первый (корневой) узел графа
- #param("Node *last_head_ptr = nullptr") — указатель на последний узел в списке заголовков
- #param("int nodes_total = 0") — общее количество узлов в графе

#line(stroke: 1pt, length: 100%)

```cpp
int nodesTotal();
```
*Описание* \
Возвращает общее количество узлов в графе.

*Возвращаемое значение*: \
Количество узлов в графе.

#line(stroke: 1pt, length: 100%)

```cpp
Node *firstNode();
```
*Описание* \
Возвращает указатель на первый (корневой) узел графа.

*Возвращаемое значение*: \
Указатель на корневой узел или `nullptr`, если граф пуст.

#line(stroke: 1pt, length: 100%)

```cpp
Node *lastNode();
```
*Описание* \
Возвращает указатель на последний узел графа в списке заголовков.

*Возвращаемое значение*: \
Указатель на последний узел или `nullptr`, если граф пуст.

#line(stroke: 1pt, length: 100%)

```cpp
bool graphIsEmpty();
```
*Описание* \
Проверяет, содержит ли граф какие-либо узлы.

*Возвращаемое значение*: \
`true` если граф пуст, `false` если содержит узлы.

#line(stroke: 1pt, length: 100%)

```cpp
Node *createNode(string id);
```
*Описание* \
Создает новый узел графа с заданным идентификатором.

*Параметры*:
- #param("id") — уникальный строковый идентификатор узла

*Возвращаемое значение*: \
Указатель на созданный узел.

#line(stroke: 1pt, length: 100%)

```cpp
Adjent *createAdjent(Node *node);
```
*Описание* \
Создает новый элемент списка смежности, указывающий на заданный узел.

*Параметры*:
- #param("node") — указатель на заголовок, соответствующий этой вершине

*Возвращаемое значение*: \
Указатель на созданный элемент списка смежности.

#line(stroke: 1pt, length: 100%)

```cpp
bool alreadyInGraph(Node *node);
```
*Описание* \
Проверяет, содержится ли определенный узел в графе.

*Параметры*:
- #param("node") — указатель на проверяемый узел

*Возвращаемое значение*: \
`true` если узел найден в графе, `false` в противном случае.

#line(stroke: 1pt, length: 100%)

```cpp
bool alreadyInGraph(string id);
```
*Описание* \
Проверяет, содержится ли узел с заданным идентификатором в графе.

*Параметры*:
- #param("id") — уникальный идентификатор узла

*Возвращаемое значение*: \
`true` если узел с таким идентификатором найден, `false` в противном случае.

#line(stroke: 1pt, length: 100%)

```cpp
Node *getNodeById(string id);
```
*Описание* \
Находит узел по его идентификатору.

*Параметры*:
- #param("id") — уникальный идентификатор узла

*Возвращаемое значение*: \
Указатель на найденный узел или `nullptr`, если узел не найден.

#line(stroke: 1pt, length: 100%)

```cpp
vector<Node *> adjentNodes(Node *node);
```
*Описание* \
Получает вектор всех узлов, следующих за указанным узлом (смежные узлы).

*Параметры*:
- #param("node") — указатель на исходный узел

*Возвращаемое значение*: \
Вектор указателей на следующие узлы.

#line(stroke: 1pt, length: 100%)

```cpp
void connect(Node *node, vector<Node *> to_another_nodes);
```
*Описание* \
Связывает узел с другими узлами, создавая направленные ребра.

*Параметры*:
- #param("node") — указатель на исходный узел
- #param("to_another_nodes") — вектор указателей на узлы, в которые нужно попасть из исходного узла

*Особенности*: \
Функция проверяет, что оба узла уже добавлены в граф.

#line(stroke: 1pt, length: 100%)

```cpp
void connect(string id, vector<string> to_another_ids);
```
*Описание* \
Связывает узел с другими узлами по их идентификаторам.

*Параметры*:
- #param("id") — уникальный идентификатор исходного узла
- #param("to_another_ids") — вектор идентификаторов узлов, в которые нужно попасть

*Особенности*: \
Функция проверяет, что все узлы уже добавлены в граф.

#line(stroke: 1pt, length: 100%)

```cpp
Adjent *getPreviousAdjentInList(Node *node, Adjent *adjent);
```
*Описание* \
Получает предыдущий элемент списка смежности для заданного элемента.

*Параметры*:
- #param("node") — указатель на заголовок узла
- #param("adjent") — элемент списка смежности этого заголовка

*Возвращаемое значение*: \
Указатель на предыдущий элемент списка смежности или `nullptr`, если элемент первый.

#line(stroke: 1pt, length: 100%)

```cpp
Node *getPreviousNodeInList(Node *node);
```
*Описание* \
Получает предыдущий узел в списке заголовков графа.

*Параметры*:
- #param("node") — указатель на текущий узел

*Возвращаемое значение*: \
Указатель на предыдущий узел или `nullptr`, если узел первый.

#line(stroke: 1pt, length: 100%)

```cpp
void addNode(Node *node);
```
*Описание* \
Добавляет новый узел в граф, не связывая его с другими узлами.

*Параметры*:
- #param("node") — указатель на добавляемый узел

#line(stroke: 1pt, length: 100%)

```cpp
void deleteAdjentyList(Node *node);
```
*Описание* \
Полностью удаляет список смежности узла.

*Параметры*:
- #param("node") — заголовок, список смежности которого нужно удалить

#line(stroke: 1pt, length: 100%)

```cpp
void deleteAdjent(Node *node, Adjent *adjent);
```
*Описание* \
Удаляет конкретный элемент из списка смежности узла.

*Параметры*:
- #param("node") — узел графа, из которого можно попасть в удаляемый элемент
- #param("adjent") — элемент списка смежности для удаления

#line(stroke: 1pt, length: 100%)

```cpp
void deleteNodeFromList(Node *node);
```
*Описание* \
Удаляет узел из списка заголовков графа.

*Параметры*:
- #param("node") — заголовок для удаления из списка

#line(stroke: 1pt, length: 100%)

```cpp
void deleteNode(Node *node);
```
*Описание* \
Полностью удаляет узел из графа и все связанные с ним связи.

*Параметры*:
- #param("node") — указатель на удаляемый узел

*Особенности*: \
Удаляет все связи, ведущие к этому узлу из других узлов, а затем сам узел.

#line(stroke: 1pt, length: 100%)

```cpp
void clearGraph();
```
*Описание* \
Полностью очищает граф, удаляя все узлы и связи.

#line(stroke: 1pt, length: 100%)

```cpp
void deepFirstSearchRecursive(void (*procedure)(Node *node), Node *node,
                              Node **visited_nodes, int *last_visited);
```
*Описание* \
Вспомогательная функция рекурсивного обхода графа в глубину.

*Параметры*:
- #param("procedure") — указатель на функцию операции над узлом
- #param("node") — указатель на посещаемый узел
- #param("visited_nodes") — массив указателей на посещенные узлы
- #param("last_visited") — индекс последнего посещенного узла в массиве

#line(stroke: 1pt, length: 100%)

```cpp
void deepFirstSearch(void (*procedure)(Node *node));
```
*Описание* \
Выполняет обход графа в глубину, применяя заданную функцию к каждому узлу.

*Параметры*:
- #param("procedure") — указатель на функцию операции над узлом

*Особенности*: \
Функция гарантирует, что каждый узел будет посещен только один раз.

=== Файл parser.cpp

*Глобальные константы*:
- #param("const string SYMBOLS = \"0123456789->\"") — допустимые символы для схемы графа

*Пространства имен*:
1. #param("config") — работа с конфигурационными файлами YAML
2. #param("table") — обработка табличных данных (CSV)
3. Глобальные функции — работа со схемами графов

#line(stroke: 1pt, length: 100%)

==== Пространство имен config

*Глобальные переменные*:
- #param("std::unique_ptr<TINY_YAML::Yaml> root") — объект дерева конфигурации
- #param("const string OPERATIONS = \"operations\"") — поле доступных операций
- #param("const string SOURCE = \"source\"") — поле файлов CSV для обработки
- #param("const string FUNC = \"func\"") — поле названия функции
- #param("const string COLUMN = \"column\"") — поле номера столбца
- #param("const string PATH = \"path\"") — поле пути к файлу CSV

#line(stroke: 1pt, length: 100%)

```cpp
void load(string path);
```
*Описание* \
Загружает конфигурацию из YAML-файла.

*Параметры*:
- #param("path") — путь к конфигурационному файлу YAML

*Исключения*: \
Ловит и выводит в stderr ошибки загрузки конфигурации.

#line(stroke: 1pt, length: 100%)

```cpp
void clear();
```
*Описание* \
Освобождает память, занятую объектом конфигурации.

#line(stroke: 1pt, length: 100%)

```cpp
std::vector<std::string> getIds();
```
*Описание* \
Получает идентификаторы всех доступных операций из конфигурации.

*Возвращаемое значение*: \
Вектор строковых идентификаторов операций.

*Примечание*: \
Возвращает пустой вектор, если конфигурация не загружена.

#line(stroke: 1pt, length: 100%)

```cpp
map<string, string> checkFunctions();
```
*Описание* \
Проверяет наличие операций, указанных в конфигурации, в глобальном словаре операций.

*Возвращаемое значение*: \
Словарь ненайденных функций, где ключ — id операции, значение — имя функции.

*Логика работы*:
1. Получает все ID операций из конфигурации
2. Для каждого ID получает имя функции
3. Проверяет наличие функции в `operation_map`
4. Возвращает отсутствующие функции

#line(stroke: 1pt, length: 100%)

```cpp
int getColumnById(string id);
```
*Описание* \
Получает номер столбца для операции по её идентификатору.

*Параметры*:
- #param("id") — уникальный идентификатор операции

*Возвращаемое значение*: \
Номер столбца (0-based) или `-1` при ошибке.

*Исключения*: \
Ловит исключения преобразования строки в число.

#line(stroke: 1pt, length: 100%)

```cpp
string getFuncById(string id);
```
*Описание* \
Получает имя функции для операции по её идентификатору.

*Параметры*:
- #param("id") — уникальный идентификатор операции

*Возвращаемое значение*: \
Имя функции или пустая строка при ошибке.

#line(stroke: 1pt, length: 100%)

```cpp
string getCSV();
```
*Описание* \
Получает путь к CSV-файлу для обработки из конфигурации.

*Возвращаемое значение*: \
Путь к CSV-файлу или пустая строка при ошибке.

=== Пространство имен table

*Глобальные переменные*:
- #param("vector<vector<string>> table") — двумерный массив для хранения табличных данных

*Типы данных*:
```cpp
enum ColumnType {
  NUMERIC,   // числовой тип данных
  STRING,    // строковый тип данных  
  UNKNOWN    // неизвестный тип данных
};
```

#line(stroke: 1pt, length: 100%)

```cpp
void read(string path, char delimiter);
```
*Описание* \
Читает табличные данные из CSV-файла.

*Параметры*:
- #param("path") — путь к CSV-файлу
- #param("delimiter") — разделитель полей

*Формат файла*: \
Каждая строка файла — строка таблицы, поля разделены указанным разделителем.

#line(stroke: 1pt, length: 100%)

```cpp
void clear();
```
*Описание* \
Очищает таблицу, освобождая память.

#line(stroke: 1pt, length: 100%)

```cpp
bool isNumneric(string &s);
```
*Описание* \
Проверяет, является ли строка числом.

*Параметры*:
- #param("s") — проверяемая строка

*Возвращаемое значение*: \
`true` если строка может быть преобразована в число, `false` в противном случае.

*Алгоритм*: \
Использует `std::stod` для проверки возможности преобразования.

#line(stroke: 1pt, length: 100%)

```cpp
ColumnType getTypeOfColumn(int column);
```
*Описание* \
Определяет тип данных в указанном столбце таблицы.

*Параметры*:
- #param("column") — номер столбца (0-based)

*Возвращаемое значение*: \
Тип данных столбца: `NUMERIC`, `STRING` или `UNKNOWN`.

*Логика работы*: \
Анализирует все строки столбца:
- Если все значения — числа → `NUMERIC`
- Если есть хотя бы одна строка → `STRING`
- В противном случае → `UNKNOWN`

#line(stroke: 1pt, length: 100%)

```cpp
vector<float> readNumericColumn(int column);
```
*Описание* \
Считывает столбец как вектор чисел с плавающей точкой.

*Параметры*:
- #param("column") — номер столбца (0-based)

*Возвращаемое значение*: \
Вектор значений типа `float`.

*Примечание*: \
Пропускает строки, где столбец выходит за границы.

#line(stroke: 1pt, length: 100%)

```cpp
vector<string> readStringColumn(int column);
```
*Описание* \
Считывает столбец как вектор строк.

*Параметры*:
- #param("column") — номер столбца (0-based)

*Возвращаемое значение*: \
Вектор строковых значений.

*Примечание*: \
Пропускает строки, где столбец выходит за границы.

*Глобальные функции*

```cpp
vector<string> split(const string &s, const string &delimiter);
```
*Описание* \
Разделяет строку на подстроки по указанному разделителю.

*Параметры*:
- #param("s") — исходная строка
- #param("delimiter") — разделитель

*Возвращаемое значение*: \
Вектор подстрок.

*Алгоритм*: \
Итеративно находит все вхождения разделителя.

#line(stroke: 1pt, length: 100%)

```cpp
int countSubstrOccurrences(string str1, string str2);
```
*Описание* \
Подсчитывает количество вхождений подстроки в строку (рекурсивная реализация).

*Параметры*:
- #param("str1") — строка для поиска
- #param("str2") — искомая подстрока

*Возвращаемое значение*: \
Количество вхождений подстроки.

*Рекурсивный алгоритм*: \
Базовый случай: если строка короче подстроки, возвращает 0.
Рекурсивный шаг: проверяет начало строки и вызывает себя для остатка.

#line(stroke: 1pt, length: 100%)

```cpp
vector<string> getScheme(std::istream &is);
```
*Описание* \
Считывает схему графа из входного потока.

*Параметры*:
- #param("is") — входной поток (например, `std::cin`)

*Возвращаемое значение*: \
Вектор строк, представляющих схему графа.

*Формат ввода*: \
Строки считываются до тех пор, пока не встретится строка "end".

#line(stroke: 1pt, length: 100%)

*Типы ошибок схемы*:
```cpp
enum SchenmeError {
  EMPTY,                 // пустая строка
  UNEXPECTED_DELIMITER, // разделитель в начале или конце
  UNEXPECTED_SYMBOLS,   // недопустимые символы
  INDEX_OUT_OF_RANGE    // индекс вне диапазона
};
```

```cpp
vector<vector<SchenmeError>> checkScheme(vector<string> &scheme,
                                         vector<string> &ids);
```
*Описание* \
Проверяет корректность схемы графа.

*Параметры*:
- #param("scheme") — вектор строк схемы
- #param("ids") — вектор доступных идентификаторов операций

*Возвращаемое значение*: \
Двумерный вектор ошибок для каждой строки схемы.

*Проверки*:
1. Пустая строка
2. Разделитель "->" в начале или конце
3. Недопустимые символы (не из `SYMBOLS`)
4. Индексы вне диапазона `[1, ids.size()]`

#line(stroke: 1pt, length: 100%)

```cpp
void createGraphFromScheme(vector<string> scheme);
```
*Описание* \
Создает граф по схеме, где узлы обозначены идентификаторами.

*Параметры*:
- #param("scheme") — вектор строк схемы

*Формат схемы*: \
`"id1->id2->id3"` — создает цепочку узлов с указанными идентификаторами.

*Алгоритм*: \
1. Создает узлы по идентификаторам
2. Добавляет их в граф
3. Создает связи между последовательными узлами

#line(stroke: 1pt, length: 100%)

```cpp
void createGraphFromScheme(vector<string> scheme, vector<string> ids);
```
*Описание* \
Создает граф по схеме, где узлы обозначены индексами идентификаторов.

*Параметры*:
- #param("scheme") — вектор строк схемы с индексами
- #param("ids") — вектор идентификаторов операций

*Формат схемы*: \
`"1->2->3"` — создает цепочку узлов с идентификаторами `ids[0]`, `ids[1]`, `ids[2]`.

*Примечание*: \
Индексы в схеме начинаются с 1 (человекочитаемый формат).

=== Файл utils.cpp

*Глобальные константы*:
- #param("const string SETUP = \"setup.conf\"") — имя файла конфигурации путей

*Пространства имен*:
1. #param("logger") — логирование результатов операций
2. #param("tui") — текстовый пользовательский интерфейс (меню, ввод, валидация)
3. Глобальные функции — вспомогательные утилиты

*Используемые библиотеки*:
- `<filesystem>` — работа с файловой системой
- `<fstream>` — работа с файлами
- `<unistd.h>` — системные вызовы (для некоторых платформ)

#line(stroke: 1pt, length: 100%)

==== Пространство имен logger

*Глобальные переменные*:
- #param("fstream log") — поток для записи логов

*Назначение*: \
Ведение журнала выполнения операций, запись результатов и предупреждений.

#line(stroke: 1pt, length: 100%)

```cpp
void openLog(string path);
```
*Описание* \
Открывает файл лога для записи.

*Параметры*:
- #param("path") — путь к файлу лога

*Особенности*: \
Открывает файл в режиме записи (`std::ios::out`). При ошибке открытия выводит сообщение в `std::cerr`.

#line(stroke: 1pt, length: 100%)

```cpp
void writeResult(string id, float res);
```
*Описание* \
Записывает результат числовой операции в лог.

*Параметры*:
- #param("id") — уникальный идентификатор операции
- #param("res") — результат выполнения операции (число с плавающей точкой)

*Формат записи*: \
`id >> res`

*Пример*: \
`operation1 >> 42.5`

#line(stroke: 1pt, length: 100%)

```cpp
void writeResult(string id, string res);
```
*Описание* \
Записывает результат строковой операции в лог.

*Параметры*:
- #param("id") — уникальный идентификатор операции
- #param("res") — результат выполнения операции (строка)

*Формат записи*: \
`id >> res`

*Пример*: \
`operation2 >> "concatenated_string"`

#line(stroke: 1pt, length: 100%)

```cpp
void warning(string message);
```
*Описание* \
Записывает предупреждающее сообщение в лог.

*Параметры*:
- #param("message") — текст предупреждения

*Использование*: \
Для сообщений об ошибках типа данных, пропущенных операциях и т.д.

#line(stroke: 1pt, length: 100%)

```cpp
void close();
```
*Описание* \
Закрывает файл лога.

*Особенности*: \
Проверяет, открыт ли файл, перед закрытием.

==== Пространство имен tui

*Назначение*: \
Реализация текстового пользовательского интерфейса для выбора файлов и валидации ввода.

#line(stroke: 1pt, length: 100%)

```cpp
void displayFileMenu(const std::vector<std::string> &files);
```
*Описание* \
Отображает список файлов в виде нумерованного меню.

*Параметры*:
- #param("files") — вектор строк с именами файлов

*Формат вывода*:
```
=== Доступные файлы ===
[1] file1.csv
[2] file2.csv
[0] Выход
=======================
```

#line(stroke: 1pt, length: 100%)

```cpp
bool isNumber(const std::string &str);
```
*Описание* \
Проверяет, состоит ли строка только из цифр.

*Параметры*:
- #param("str") — входная строка для проверки

*Возвращаемое значение*: \
`true` если строка не пустая и содержит только цифры, `false` в противном случае.

*Алгоритм*: \
Итеративно проверяет каждый символ с помощью `std::isdigit`.

#line(stroke: 1pt, length: 100%)

```cpp
std::string trimString(const std::string &str);
```
*Описание* \
Удаляет пробельные символы в начале и конце строки.

*Параметры*:
- #param("str") — строка для обработки

*Возвращаемое значение*: \
Строка без пробелов по краям или пустая строка, если исходная состояла только из пробелов.

*Удаляемые символы*: \
Пробелы и табуляции (`" \t"`).

#line(stroke: 1pt, length: 100%)

```cpp
bool processUserInput(std::string &input);
```
*Описание* \
Обрабатывает ввод пользователя: считывает строку, обрезает пробелы, проверяет на числовой формат.

*Параметры*:
- #param("input") — ссылка на строку для сохранения ввода

*Возвращаемое значение*: \
`true` если ввод корректен (число), `false` если нужно повторить ввод.

*Последовательность действий*:
1. Считывает строку из `std::cin`
2. Обрезает пробелы
3. Проверяет, является ли числом

#line(stroke: 1pt, length: 100%)

```cpp
bool safeStringToInt(const std::string &str, int &result);
```
*Описание* \
Безопасно преобразует строку в целое число с обработкой исключений.

*Параметры*:
- #param("str") — строка для преобразования
- #param("result") — ссылка для сохранения результата

*Возвращаемое значение*: \
`true` если преобразование успешно, `false` если произошло исключение.

*Использует*: \
`std::stoi` с обработкой исключений.

#line(stroke: 1pt, length: 100%)

```cpp
bool isInRange(int number, int min, int max);
```
*Описание* \
Проверяет, находится ли число в заданном диапазоне.

*Параметры*:
- #param("number") — число для проверки
- #param("min") — минимальное допустимое значение
- #param("max") — максимальное допустимое значение

*Возвращаемое значение*: \
`true` если `min ≤ number ≤ max`, `false` в противном случае.

*Дополнительно*: \
При выходе за диапазон выводит сообщение об ошибке.

#line(stroke: 1pt, length: 100%)

```cpp
int getValidatedNumberInput(const std::string &prompt, int min, int max);
```
*Описание* \
Получает валидированный числовой ввод от пользователя.

*Параметры*:
- #param("prompt") — сообщение для ввода (выводится перед ожиданием ввода)
- #param("min") — минимальное допустимое значение
- #param("max") — максимальное допустимое значение

*Возвращаемое значение*: \
Валидное целое число в диапазоне `[min, max]`.

*Алгоритм валидации*:
1. Выводит сообщение
2. Обрабатывает ввод пользователя
3. Проверяет, является ли ввод числом
4. Преобразует строку в число
5. Проверяет диапазон
6. Повторяет до получения валидного ввода

#line(stroke: 1pt, length: 100%)

```cpp
std::string selectFileFromList(const std::vector<std::string> &files);
```
*Описание* \
Основная функция для интерактивного выбора файла из списка.

*Параметры*:
- #param("files") — вектор путей к файлам

*Возвращаемое значение*: \
Выбранный путь к файлу или пустая строка, если выбран выход.

*Последовательность действий*:
1. Проверяет, не пуст ли список файлов
2. Отображает меню файлов
3. Получает выбор пользователя
4. Возвращает выбранный файл или пустую строку при выборе выхода

#line(stroke: 1pt, length: 100%)

```cpp
int getValidatedNumberInputNoContinue(const std::string &prompt, int min,
                                      int max);
```
*Описание* \
Альтернативная версия `getValidatedNumberInput` без использования `continue`.

*Параметры*:
- #param("prompt") — приглашение для ввода
- #param("min") — минимальное допустимое значение
- #param("max") — максимальное допустимое значение

*Возвращаемое значение*: \
Валидное целое число в диапазоне `[min, max]`.

*Особенности*: \
Реализована без оператора `continue`, используя только условия и циклы.

==== Глобальные функции

```cpp
vector<string> collectFiles(string path, string extension);
```
*Описание* \
Собирает все файлы с указанным расширением в директории.

*Параметры*:
- #param("path") — путь к директории для поиска
- #param("extension") — расширение файлов (например, ".txt", ".csv")

*Возвращаемое значение*: \
Вектор полных путей к найденным файлам.

*Использует*: \
`std::filesystem::directory_iterator` для обхода директории.

*Примечание*: \
Проверяет наличие подстроки с расширением в имени файла (не строгое сравнение).

#line(stroke: 1pt, length: 100%)

```cpp
void procedure(Node *node);
```
*Описание* \
Основная процедура выполнения операций над узлами графа.

*Параметры*:
- #param("node") — указатель на узел графа

*Алгоритм*:
1. Получает идентификатор операции из узла
2. Определяет тип операции через `config::getFuncById`
3. Получает номер столбца через `config::getColumnById`
4. Определяет тип данных в столбце через `table::getTypeOfColumn`
5. В зависимости от типа:
   - Для `NUMERIC`: считывает числовой столбец и вызывает числовую операцию
   - Для `STRING`: считывает строковый столбец и вызывает строковую операцию
   - Для `UNKNOWN`: записывает предупреждение в лог
6. Записывает результат в лог через `logger::writeResult`

*Используемые компоненты*:
- Конфигурация (`config::`)
- Табличные данные (`table::`)
- Операции (`callOperation`)
- Логирование (`logger::`)

*Обработка ошибок*: \
При неизвестном типе данных записывает предупреждение и пропускает операцию.

*Ключевая роль*: \
Связывает граф операций с фактическим выполнением над данными.

=== Файл router.cpp

*Глобальные константы*:
- #param("const string WORKING_DIR = \"data\"") — рабочая директория для хранения конфигурационных файлов и данных

*Пространства имен*:
1. #param("SimpleDAG") — основное пространство имен приложения
2. #param("SimpleDAG::Internal") — внутренние вспомогательные функции

*Назначение файла*: \
Основной маршрутизатор приложения, координирующий загрузку конфигурации, данных, обработку схемы графа и выполнение операций.

#line(stroke: 1pt, length: 100%)

==== Пространство имен SimpleDAG

```cpp
int run();
```
*Описание* \
Главная функция запуска приложения SimpleDAG.

*Возвращаемое значение*: \
Код завершения программы:
- `0` — успешное выполнение
- `1` — ошибка выполнения

*Последовательность выполнения*:
1. Загрузка конфигурации (`Internal::loadConfiguration`)
2. Проверка конфигурации (`Internal::validateConfiguration`)
3. Загрузка данных (`Internal::loadDataTable`)
4. Отображение доступных операций (`Internal::displayAvailableOperations`)
5. Инициализация логирования (`Internal::initializeLogging`)
6. Обработка схемы графа (`Internal::processGraphScheme`)
7. Выполнение операций обходом в глубину (`deepFirstSearch(procedure)`)
8. Очистка ресурсов (`Internal::cleanup`)

*Ключевые особенности*:
- Интегрирует все компоненты системы
- Обеспечивает последовательное выполнение этапов
- Обрабатывает ошибки на каждом этапе

==== Пространство имен SimpleDAG::Internal

*Назначение*: \
Внутренние вспомогательные функции, скрывающие детали реализации от основного интерфейса.

#line(stroke: 1pt, length: 100%)

```cpp
bool loadConfiguration(const std::string &workingDir);
```
*Описание* \
Загружает конфигурацию из YAML файла в указанной рабочей директории.

*Параметры*:
- #param("workingDir") — рабочая директория для поиска конфигурационных файлов

*Возвращаемое значение*: \
`true` если конфигурация успешно загружена, `false` в случае ошибки.

*Алгоритм*:
1. Собирает все файлы с расширением `.yaml` в рабочей директории
2. Отображает меню выбора файла через `tui::selectFileFromList`
3. Загружает выбранный файл через `config::load`

*Сообщения об ошибках*:
- "Не найдены конфигурационные файлы в директории ..."
- "Файл конфигурации не выбран"

#line(stroke: 1pt, length: 100%)

```cpp
bool validateConfiguration();
```
*Описание* \
Проверяет валидность загруженной конфигурации.

*Возвращаемое значение*: \
`true` если конфигурация валидна, `false` если найдены неизвестные функции.

*Алгоритм*:
1. Проверяет функции через `config::checkFunctions`
2. Если найдены неизвестные функции, выводит их список
3. Сообщает о необходимости использовать только доступные функции

*Формат вывода ошибок*:
```
Найдены неизвестные функции в файле конфигурации:
id: op1, функция: unknown_func
id: op2, функция: another_unknown
```

#line(stroke: 1pt, length: 100%)

```cpp
bool loadDataTable();
```
*Описание* \
Загружает данные из CSV файла, указанного в конфигурации.

*Возвращаемое значение*: \
`true` если данные успешно загружены, `false` в случае ошибки.

*Алгоритм*:
1. Получает имя CSV файла из конфигурации через `config::getCSV`
2. Формирует полный путь: `WORKING_DIR + "/" + csvFile`
3. Загружает таблицу через `table::read`

*Сообщения об ошибках*:
- "Не указан файл данных в конфигурации"

#line(stroke: 1pt, length: 100%)

```cpp
void displayAvailableOperations();
```
*Описание* \
Отображает список доступных операций из конфигурации.

*Формат вывода*:
```
=== Доступные операции ===
[1] operation1
[2] operation2
[3] operation3
==========================
```

*Использует*: \
`config::getIds()` для получения списка идентификаторов операций.

#line(stroke: 1pt, length: 100%)

```cpp
void initializeLogging();
```
*Описание* \
Инициализирует систему логирования с временной меткой в имени файла.

*Алгоритм*:
1. Получает текущее время через `time(0)`
2. Преобразует в строку через `ctime`
3. Открывает лог-файл в рабочей директории с именем, содержащим временную метку

*Пример имени файла*: \
`data/Thu Mar 14 10:30:00 2024`

*Использует*: \
`logger::openLog()` для открытия файла лога.

#line(stroke: 1pt, length: 100%)

```cpp
bool processGraphScheme(std::vector<std::string> &ids);
```
*Описание* \
Обрабатывает ввод и валидацию схемы графа от пользователя.

*Параметры*:
- #param("ids") — список идентификаторов доступных операций

*Возвращаемое значение*: \
`true` если схема успешно обработана, `false` в случае ошибки.

*Последовательность действий*:
1. Выводит инструкции (глобальная константа `INSRUCTIONS`)
2. В цикле:
   - Запрашивает ввод схемы через `getScheme(std::cin)`
   - Проверяет валидность через `validateAndDisplayScheme`
   - Если есть ошибки, просит исправить и повторить ввод
   - Если схема валидна, выходит из цикла
3. Создает граф по схеме через `createGraphFromScheme`

*Формат ввода*: \
Многострочный ввод, завершающийся строкой "end"

*Интерактивный диалог*: \
"Ввод" → пользователь вводит схему → проверка → сообщение об ошибках или успехе

#line(stroke: 1pt, length: 100%)

```cpp
bool validateAndDisplayScheme(vector<string> &scheme, vector<string> &ids);
```
*Описание* \
Проверяет схему на валидность и отображает ошибки.

*Параметры*:
- #param("scheme") — вектор строк схемы графа
- #param("ids") — список идентификаторов доступных операций

*Возвращаемое значение*: \
`true` если схема валидна, `false` если найдены ошибки.

*Алгоритм*:
1. Проверяет схему через `checkScheme(scheme, ids)`
2. Для каждой строки с ошибками вызывает `displaySchemeErrors`
3. Возвращает `true` только если ни в одной строке нет ошибок

*Сообщения*:
- "Обнаружены ошибки в схеме:" — при наличии ошибок
- "Схема графа корректна!" — при успешной валидации

#line(stroke: 1pt, length: 100%)

```cpp
void displaySchemeErrors(const std::string &schemeLine,
                         const std::vector<SchenmeError> &errors,
                         int lineNumber);
```
*Описание* \
Отображает ошибки в конкретной строке схемы графа.

*Параметры*:
- #param("schemeLine") — строка схемы с ошибкой
- #param("errors") — вектор ошибок для данной строки
- #param("lineNumber") — номер строки в схеме (начиная с 1)

*Формат вывода*: \
`Строка X "схема": ошибка1; ошибка2; ...`

*Типы ошибок и их описание*:
- `EMPTY` → "пустая строка"
- `UNEXPECTED_DELIMITER` → "неожиданный разделитель"
- `UNEXPECTED_SYMBOLS` → "недопустимые символы"
- `INDEX_OUT_OF_RANGE` → "индекс вне диапазона"

#line(stroke: 1pt, length: 100%)

```cpp
void cleanup();
```
*Описание* \
Освобождает все ресурсы и очищает глобальное состояние программы.

*Последовательность очистки*:
1. Конфигурация: `config::clear()`
2. Табличные данные: `table::clear()`
3. Логирование: `logger::close()`
4. Граф: `clearGraph()`

*Назначение*: \
Обеспечивает корректное завершение программы, предотвращая утечки памяти.

*Глобальная константа*:
```cpp
// Константа с инструкциями для пользователя
const string INSRUCTIONS = "Введите схему графа в формате:\n"
                           "1->2->3\n"
                           "4->5\n"
                           "...\n"
                           "end\n"
                           "Где числа - номера операций из списка выше";
```

*Структура взаимодействия*:
```
run()
├── loadConfiguration()
├── validateConfiguration()
├── loadDataTable()
├── displayAvailableOperations()
├── initializeLogging()
├── processGraphScheme()
│   ├── validateAndDisplayScheme()
│   │   └── displaySchemeErrors()
│   └── createGraphFromScheme()
├── deepFirstSearch(procedure)
└── cleanup()
```

*Используемые внешние компоненты*:
- Графовые операции (`graph.h`)
- Операции над данными (`operations.h`)
- Парсер конфигурации (`parser.h`)
- Утилиты (`utils.h`)
- Графический вывод (`graphics.h`)

#pagebreak()

= Инструкция пользователя

== Обзор системы SimpleDAG

**SimpleDAG** — система для автоматической обработки табличных данных через направленный ациклический граф (DAG) операций. Программа позволяет определить последовательность операций над CSV-данными и выполнить их в указанном порядке.

*Основные возможности*:
- Загрузка конфигурации операций из YAML-файлов
- Обработка CSV-таблиц с автоматическим определением типов данных
- Построение графа зависимостей между операциями
- Выполнение операций с логированием результатов
- Интерактивный текстовый интерфейс

== Подготовка к работе

=== Структура директорий

Перед запуском программы убедитесь, что у вас есть следующая структура директорий:

```
path/
├── SimpleDAG.out          # Исполняемый файл
├── data/                  # Директория с данными
│   ├── config.yaml       # Файл конфигурации
│   └── data.csv          # CSV-файл с данными
└── logs/                 # Директория для логов (создается автоматически)
```

=== Подготовка конфигурационного файла

Создайте YAML-файл конфигурации в директории `data/`. Пример `config.yaml`:

```yaml
operations:
  total_sales:
    func: sum
    column: 0
  average_price:
    func: average
    column: 1
  product_names:
    func: concatinate
    column: 2

path: data.csv
```

*Поля конфигурации*:
- `operations` — словарь операций, где ключ — уникальный ID операции
  - `func` — тип операции (`sum`, `average`, `concatinate`)
  - `column` — номер столбца в CSV (начиная с 0)
- `path` — имя CSV-файла в директории `data/`

=== Подготовка CSV-файла

Создайте CSV-файл в директории `data/`. Пример `data.csv`:

```csv
10.5,25.99,ProductA
15.2,32.50,ProductB
8.7,18.75,ProductC
```

*Требования к CSV*:
- Разделитель — запятая
- Первая строка — данные (заголовки не поддерживаются)
- Колонки могут содержать числа или строки
- Кодировка — UTF-8

== Рабочий процесс

=== Шаг 1: Выбор конфигурационного файла

Программа автоматически найдет все YAML-файлы в директории `data/` и отобразит меню выбора:

```
=== Доступные файлы ===
[1] config1.yaml
[2] config2.yaml
[0] Выход
=======================
Выберите файл (0-2): 
```

*Действия*:
- Введите номер нужного файла и нажмите `Enter`
- Для выхода введите `0`

=== Шаг 2: Проверка конфигурации

После выбора файла система:
1. Проверит корректность YAML-синтаксиса
2. Убедится, что указанные функции существуют
3. Проверит наличие указанного CSV-файла

В случае ошибок будут выведены соответствующие сообщения.

=== Шаг 3: Просмотр доступных операций

Система отобразит список операций из конфигурации:

```
=== Доступные операции ===
[1] total_sales
[2] average_price  
[3] product_names
==========================
```

=== Шаг 4: Ввод схемы графа

Введите схему зависимостей между операциями. Система отобразит инструкции:

```
Введите схему графа в формате:
1->2->3
4->5
...
end
```
Где числа - номера операций из списка выше

*Формат ввода*:
- Каждая строка — цепочка операций
- `->` — обозначает зависимость (операция слева должна выполниться перед операцией справа)
- `end` — завершение ввода

*Примеры*:

1. Линейная цепочка:
   ```
   1->2->3
   end
   ```
   Выполнит операции 1, 2, 3 последовательно.

2. Несколько независимых цепочек:
   ```
   1->2
   3->4
   end
   ```
   Выполнит цепочку (1,2), но (3,4) пропустит. У графа операций первый узел должен быть общим. 

3. Сложная схема:
   ```
   1->2->4
   1->3->4
   end
   ```
   Операция 1 выполнится первой, затем 2, 3 и только потом 4.

=== Шаг 5: Валидация схемы

Система проверит введенную схему на:
1. Корректность формата
2. Корректность номеров операций

При обнаружении ошибок будут выведены сообщения. Пример:

```
❌ Обнаружены ошибки в схеме:
Строка 1 "1->2->": неожиданный разделитель;
Строка 3 "5->6": индекс вне диапазона;
```

Исправьте ошибки и введите схему заново.

=== Шаг 6: Выполнение операций

После успешной валидации система:
1. Построит граф операций
2. Выполнит операции в правильном порядке
3. Запишет результаты в лог-файл

Отобразится сообщение: `Схема графа корректна!`

=== Шаг 7: Просмотр результатов

Результаты выполнения сохраняются в файл лога в директории `data/` с именем, содержащим временную метку (например: `data/Mon Dec  1 22:04:19 2025`).

Содержимое лог-файла:
```
total_sales >> 34.4
average_price >> 25.7467
product_names >> ProductAProductBProductC
```

*Формат*: `ID_операции >> результат`

== Работа с ошибками

=== Ошибки загрузки конфигурации

#table(
  columns: (1fr, 1fr, 1fr),
  stroke: (x: .5pt, y: .5pt),
  align: (left, left, left),
  inset: 5pt,
  
  [*Ошибка*], [*Причина*], [*Решение*],
  
  [*"Не найдены конфигурационные файлы"*],
  [В директории #highlight(`data/`) нет YAML-файлов],
  [Разместите конфигурационный файл в #highlight(`data/`)],
  
  [*"Файл конфигурации не выбран"*],
  [Пользователь выбрал выход (0)],
  [Запустите программу заново],
  
  [*"Найдены неизвестные функции"*],
  [В конфигурации указана несуществующая функция],
  [Используйте только #highlight(`sum`), #highlight(`average`), #highlight(`concatinate`)],
)

=== Ошибки ввода схемы

#table(
  columns: (1fr, 1fr, 1fr),
  stroke: (x: .5pt, y: .5pt),
  align: (left, left, left),
  inset: 5pt,
  
  [*Ошибка*], [*Пример*], [*Исправление*],
  
  [*Пустая строка*],
  [#highlight(`(пустая строка)`)],
  [Удалите пустую строку],
  
  [*Неожиданный разделитель*],
  [#highlight(`->2->3`) или #highlight(`1->`)],
  [Убедитесь, что разделитель не в начале/конце],
  
  [*Недопустимые символы*],
  [#highlight(`1->a->3`)],
  [Используйте только цифры и #highlight(`->`)],
  
  [*Индекс вне диапазона*],
  [#highlight(`1->10`) при 5 операциях],
  [Используйте номера из списка операций],
)

=== Ошибки выполнения операций

#table(
  columns: (1fr, 1fr),
  stroke: (x: .5pt, y: .5pt),
  align: (left, left),
  inset: 5pt,
  
  [*Ситуация*], [*Поведение системы*],
  
  [*Нечисловые данные в числовой колонке*],
  [Пропуск строки, предупреждение в лог],
  
  [*Пустая колонка*],
  [Возврат нуля/пустой строки],
  
  [*Отсутствующий CSV-файл*],
  [Сообщение об ошибке, завершение работы],
)
== Пример полного сеанса работы

```
$ ./SimpleDAG.out

=== Доступные файлы ===
[1] sales_config.yaml
[2] inventory_config.yaml
[0] Выход
=======================
Выберите файл (0-2): 1

=== Доступные операции ===
[1] calculate_total
[2] find_average
[3] concatenate_names
==========================

Введите схему графа в формате:
1->2->3
4->5
...
end
Где числа - номера операций из списка выше

Ввод
1->2->3
end

✅ Схема графа корректна!
Выполнение завершено. Результаты в data/Mon Dec  1 22:04:19 2025
```

== Клавиши управления

#table(
  columns: (auto, auto, auto),
  stroke: (x: .5pt, y: .5pt),
  align: (left, left, left),
  inset: 5pt,
  
  [*Клавиша*], [*Действие*], [*Контекст*],
  
  [#highlight(`0-9`)],
  [Выбор пункта меню],
  [Меню выбора файла],
  
  [#highlight(`Enter`)],
  [Подтверждение ввода],
  [Все поля ввода],
  
  [#highlight(`Ctrl+C`)],
  [Аварийный выход],
  [В любой момент],
)

== Ограничения системы

1. Максимальное количество операций — ограничено памятью
2. Размер CSV-файла — ограничено памятью
3. Типы данных — только числа и строки
4. Операции — только предопределенный набор
5. Параллельное выполнение — не поддерживается (последовательное)

#pagebreak()

= Листинг

== Заголовочные файлы

=== graph.h
#listing("include/graph.h")

=== operations.h
#listing("include/operations.h")

=== parser.h
#listing("include/parser.h")

=== router.h
#listing("include/router.h")

=== utils.h
#listing("include/utils.h")

=== graphics.h
#listing("include/graphics.h")

== Исходные файлы

=== main.cpp
#listing("main.cpp")

=== graph.cpp
#listing("src/graph.cpp")

=== operations.cpp
#listing("src/operations.cpp")

=== parser.cpp
#listing("src/parser.cpp")

=== router.cpp
#listing("src/router.cpp")

=== utils.cpp
#listing("src/utils.cpp")

== Конфигурационные файлы

=== Makefile (основной)
#listing("Makefile")

== Тесты

=== tests/graph/test_graph.cpp
#listing("tests/graph/test_graph.cpp")

=== tests/operations/test_operations.cpp
#listing("tests/operations/test_operations.cpp")

=== tests/parser/test_parser.cpp
#listing("tests/parser/test_parser.cpp")

=== tests/utils/test_utils.cpp
#listing("tests/utils/test_utils.cpp")

== Скрипты

=== buildTests.sh
#listing("buildTests.sh")

=== runTests.sh
#listing("runTests.sh")

=== .github/workflows/ci.yml 
#listing(".github/workflows/ci.yml")
